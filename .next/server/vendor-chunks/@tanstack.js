"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnVisibility),\n/* harmony export */   GlobalFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFiltering),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   RowExpanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowExpanding),\n/* harmony export */   RowPagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPagination),\n/* harmony export */   RowPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   RowSorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztHQVNHLEdBQzRCO0FBQ29CO0FBQ2Q7QUFFckMsRUFBRTtBQUVGOztDQUVDLEdBQ0QsU0FBU0UsV0FBV0MsSUFBSSxFQUFFQyxLQUFLO0lBQzdCLE9BQU8sQ0FBQ0QsT0FBTyxPQUFPRSxpQkFBaUJGLFFBQVEsV0FBVyxHQUFFSCxnREFBbUIsQ0FBQ0csTUFBTUMsU0FBU0Q7QUFDakc7QUFDQSxTQUFTRSxpQkFBaUJFLFNBQVM7SUFDakMsT0FBT0MsaUJBQWlCRCxjQUFjLE9BQU9BLGNBQWMsY0FBY0Usa0JBQWtCRjtBQUM3RjtBQUNBLFNBQVNDLGlCQUFpQkQsU0FBUztJQUNqQyxPQUFPLE9BQU9BLGNBQWMsY0FBYyxDQUFDO1FBQ3pDLE1BQU1HLFFBQVFDLE9BQU9DLGNBQWMsQ0FBQ0w7UUFDcEMsT0FBT0csTUFBTUcsU0FBUyxJQUFJSCxNQUFNRyxTQUFTLENBQUNSLGdCQUFnQjtJQUM1RDtBQUNGO0FBQ0EsU0FBU0ksa0JBQWtCRixTQUFTO0lBQ2xDLE9BQU8sT0FBT0EsY0FBYyxZQUFZLE9BQU9BLFVBQVVPLFFBQVEsS0FBSyxZQUFZO1FBQUM7UUFBYztLQUFvQixDQUFDQyxRQUFRLENBQUNSLFVBQVVPLFFBQVEsQ0FBQ0UsV0FBVztBQUMvSjtBQUNBLFNBQVNDLGNBQWNDLE9BQU87SUFDNUIscURBQXFEO0lBQ3JELE1BQU1DLGtCQUFrQjtRQUN0QkMsT0FBTyxDQUFDO1FBQ1IsY0FBYztRQUNkQyxlQUFlLEtBQU87UUFDdEIsT0FBTztRQUNQQyxxQkFBcUI7UUFDckIsR0FBR0osT0FBTztJQUNaO0lBRUEsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0ssU0FBUyxHQUFHdkIsMkNBQWMsQ0FBQyxJQUFPO1lBQ3ZDeUIsU0FBU3hCLGlFQUFXQSxDQUFDa0I7UUFDdkI7SUFFQSxzRUFBc0U7SUFDdEUsTUFBTSxDQUFDQyxPQUFPTSxTQUFTLEdBQUcxQiwyQ0FBYyxDQUFDLElBQU11QixTQUFTRSxPQUFPLENBQUNFLFlBQVk7SUFFNUUsZ0ZBQWdGO0lBQ2hGLG9EQUFvRDtJQUNwREosU0FBU0UsT0FBTyxDQUFDRyxVQUFVLENBQUNDLENBQUFBLE9BQVM7WUFDbkMsR0FBR0EsSUFBSTtZQUNQLEdBQUdYLE9BQU87WUFDVkUsT0FBTztnQkFDTCxHQUFHQSxLQUFLO2dCQUNSLEdBQUdGLFFBQVFFLEtBQUs7WUFDbEI7WUFDQSwwRUFBMEU7WUFDMUUsU0FBUztZQUNUQyxlQUFlUyxDQUFBQTtnQkFDYkosU0FBU0k7Z0JBQ1RaLFFBQVFHLGFBQWEsSUFBSSxRQUFRSCxRQUFRRyxhQUFhLENBQUNTO1lBQ3pEO1FBQ0Y7SUFDQSxPQUFPUCxTQUFTRSxPQUFPO0FBQ3pCO0FBRXFDLENBQ3JDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpbGUtZHJpdmUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/YTE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogcmVhY3QtdGFibGVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cblxuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVUYWJsZSIsImZsZXhSZW5kZXIiLCJDb21wIiwicHJvcHMiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsInNldFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic2V0T3B0aW9ucyIsInByZXYiLCJ1cGRhdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\n// Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return (depArgs)=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps(depArgs);\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n    return {\n        debug: ()=>{\n            var _tableOptions$debugAl;\n            return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n        },\n        key:  true && key,\n        onChange\n    };\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), getMemoOptions(table.options, \"debugCells\", \"cell.getContext\"))\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getFlatColumns\")),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getLeafColumns\"))\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to unknown, because we know more than the compiler here.\n    return column;\n}\nconst debug = \"debugHeaders\";\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, getMemoOptions(table.options, debug, \"getHeaderGroups\"));\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, getMemoOptions(table.options, debug, \"getCenterHeaderGroups\"));\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, getMemoOptions(table.options, debug, \"getLeftHeaderGroups\"));\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, getMemoOptions(table.options, debug, \"getRightHeaderGroups\"));\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getFooterGroups\"));\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getLeftFooterGroups\"));\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getCenterFooterGroups\"));\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getRightFooterGroups\"));\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getFlatHeaders\"));\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeftFlatHeaders\"));\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getCenterFlatHeaders\"));\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getRightFlatHeaders\"));\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getCenterLeafHeaders\"));\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getLeftLeafHeaders\"));\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getRightLeafHeaders\"));\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeafHeaders\"));\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCells\")),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCellsByColumnId\"))\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n//\nconst ColumnFaceting = {\n    createColumn: (column, table)=>{\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst ColumnFiltering = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousFilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousFilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n    },\n    createRow: (row, _table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst ColumnGrouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst ColumnOrdering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getIndex = memo((position)=>[\n                _getVisibleLeafColumns(table, position)\n            ], (columns)=>columns.findIndex((d)=>d.id === column.id), getMemoOptions(table.options, \"debugColumns\", \"getIndex\"));\n        column.getIsFirstColumn = (position)=>{\n            var _columns$;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n        };\n        column.getIsLastColumn = (position)=>{\n            var _columns;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, getMemoOptions(table.options, \"debugTable\", \"_getOrderColumnsFn\"));\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst ColumnPinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterVisibleCells\"));\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left\n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getLeftVisibleCells\"));\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getRightVisibleCells\"));\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getLeftLeafColumns\"));\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getRightLeafColumns\"));\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, getMemoOptions(table.options, \"debugColumns\", \"getCenterLeafColumns\"));\n    }\n};\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(0, column.getIndex(position)).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getStart\"));\n        column.getAfter = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(column.getIndex(position) + 1).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getAfter\"));\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = _contextDocument || typeof document !== \"undefined\" ? document : null;\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst ColumnVisibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _ref, _table$getState$colum;\n            const childColumns = column.columns;\n            return (_ref = childColumns.length ? childColumns.some((c)=>c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, getMemoOptions(table.options, \"debugRows\", \"_getAllVisibleCells\"));\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], getMemoOptions(table.options, \"debugRows\", \"getVisibleCells\"));\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, getMemoOptions(table.options, \"debugColumns\", key));\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nfunction _getVisibleLeafColumns(table, position) {\n    return !position ? table.getVisibleLeafColumns() : position === \"center\" ? table.getCenterVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n//\nconst GlobalFiltering = {\n    getInitialState: (state)=>{\n        return {\n            globalFilter: undefined,\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\n            return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\n//\nconst RowExpanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst RowPagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        //deprecated\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPageOptions\"));\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.firstPage = ()=>{\n            return table.setPageIndex(0);\n        };\n        table.lastPage = ()=>{\n            return table.setPageIndex(table.getPageCount() - 1);\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n        };\n        table.getRowCount = ()=>{\n            var _table$options$rowCou;\n            return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n        };\n    }\n};\n//\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst RowPinning = {\n    getInitialState: (state)=>{\n        return {\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref)=>{\n                let { id } = _ref;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref3;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref4)=>{\n                let { id } = _ref4;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n    },\n    createTable: (table)=>{\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table._getPinnedRows = memo((position)=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning[position],\n                position\n            ], (visibleRows, pinnedRowIds, position)=>{\n            var _table$options$keepPi;\n            const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                const row = table.getRow(rowId, true);\n                return row.getIsAllParentsExpanded() ? row : null;\n            }) : //else get only visible rows that are pinned\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n            return rows.filter(Boolean).map((d)=>({\n                    ...d,\n                    position\n                }));\n        }, getMemoOptions(table.options, \"debugRows\", \"_getPinnedRows\"));\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterRows\"));\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getSelectedRowModel\"));\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredSelectedRowModel\"));\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedSelectedRowModel\"));\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst RowSorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\nconst builtInFeatures = [\n    Headers,\n    ColumnVisibility,\n    ColumnOrdering,\n    ColumnPinning,\n    ColumnFaceting,\n    ColumnFiltering,\n    GlobalFiltering,\n    //depends on ColumnFiltering and ColumnFaceting\n    RowSorting,\n    ColumnGrouping,\n    //depends on RowSorting\n    RowExpanding,\n    RowPagination,\n    RowPinning,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$_features, _options$initialState;\n    if ( true && (options.debugAll || options.debugTable)) {\n        console.info(\"Creating Table Instance...\");\n    }\n    const _features = [\n        ...builtInFeatures,\n        ...(_options$_features = options._features) != null ? _options$_features : []\n    ];\n    let table = {\n        _features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, getMemoOptions(options, \"debugColumns\", \"_getDefaultColumnDef\")),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllColumns\")),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumns\")),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumnsById\")),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllLeafColumns\")),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getExpandedRowModel\"));\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedMinMaxValues\"));\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedRowModel\"));\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, getMemoOptions(table.options, \"debugTable\", `getFacetedUniqueValues_${columnId}`));\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedRowModel\", ()=>{\n            table._queue(()=>{\n                table._autoResetExpanded();\n                table._autoResetPageIndex();\n            });\n        }));\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPaginationRowModel\"));\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getSortedRowModel\", ()=>table._autoResetPageIndex()));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7R0FTRyxHQUNILGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLGFBQWE7QUFDYixVQUFVO0FBQ1YscUJBQXFCO0FBQ3JCLFVBQVU7QUFDVixRQUFRO0FBQ1IsaUNBQWlDO0FBQ2pDLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixVQUFVO0FBQ1YsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBRUosb0RBQW9EO0FBQ3BELCtDQUErQztBQUUvQyw4Q0FBOEM7QUFFOUMsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxLQUFLO0FBRUwsd0NBQXdDO0FBQ3hDLG1DQUFtQztBQUNuQyxLQUFLO0FBRUwsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxLQUFLO0FBRUwsU0FBU0E7SUFDUCxPQUFPO1FBQ0xDLFVBQVUsQ0FBQ0EsVUFBVUM7WUFDbkIsT0FBTyxPQUFPRCxhQUFhLGFBQWE7Z0JBQ3RDLEdBQUdDLE1BQU07Z0JBQ1RDLFlBQVlGO1lBQ2QsSUFBSTtnQkFDRixHQUFHQyxNQUFNO2dCQUNURSxhQUFhSDtZQUNmO1FBQ0Y7UUFDQUksU0FBU0gsQ0FBQUEsU0FBVUE7UUFDbkJJLE9BQU9KLENBQUFBLFNBQVVBO0lBQ25CO0FBQ0Y7QUFFQSx3QkFBd0I7QUFFeEIscURBQXFEO0FBRXJELEdBQUc7QUFFSCxTQUFTSyxpQkFBaUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsU0FB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QUNwekIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlsZS1kcml2ZS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzPzU1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIHRhYmxlLWNvcmVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG4vLyB0eXBlIFBlcnNvbiA9IHtcbi8vICAgZmlyc3ROYW1lOiBzdHJpbmdcbi8vICAgbGFzdE5hbWU6IHN0cmluZ1xuLy8gICBhZ2U6IG51bWJlclxuLy8gICB2aXNpdHM6IG51bWJlclxuLy8gICBzdGF0dXM6IHN0cmluZ1xuLy8gICBwcm9ncmVzczogbnVtYmVyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZVxuLy8gICBuZXN0ZWQ6IHtcbi8vICAgICBmb286IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgYmFyOiAnYmFyJ1xuLy8gICAgICAgfVxuLy8gICAgIF1cbi8vICAgICBiYXI6IHsgc3ViQmFyOiBib29sZWFuIH1bXVxuLy8gICAgIGJhejoge1xuLy8gICAgICAgZm9vOiAnZm9vJ1xuLy8gICAgICAgYmFyOiB7XG4vLyAgICAgICAgIGJhejogJ2Jheidcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLy8gY29uc3QgdGVzdDogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuZm9vLjAuYmFyJ1xuLy8gY29uc3QgdGVzdDI6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmJhcidcblxuLy8gY29uc3QgaGVscGVyID0gY3JlYXRlQ29sdW1uSGVscGVyPFBlcnNvbj4oKVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28nLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vLjAuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW5IZWxwZXIoKSB7XG4gIHJldHVybiB7XG4gICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yRm46IGFjY2Vzc29yXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yS2V5OiBhY2Nlc3NvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGRpc3BsYXk6IGNvbHVtbiA9PiBjb2x1bW4sXG4gICAgZ3JvdXA6IGNvbHVtbiA9PiBjb2x1bW5cbiAgfTtcbn1cblxuLy8gSXMgdGhpcyB0eXBlIGEgdHVwbGU/XG5cbi8vIElmIHRoaXMgdHlwZSBpcyBhIHR1cGxlLCB3aGF0IGluZGljZXMgYXJlIGFsbG93ZWQ/XG5cbi8vL1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xuICAgIGluc3RhbmNlLnNldFN0YXRlKG9sZCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIFtrZXldOiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZFtrZXldKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xuICByZXR1cm4gZCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XG4gIGNvbnN0IGZsYXQgPSBbXTtcbiAgY29uc3QgcmVjdXJzZSA9IHN1YkFyciA9PiB7XG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZWN1cnNlKGFycik7XG4gIHJldHVybiBmbGF0O1xufVxuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gZGVwQXJncyA9PiB7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKGRlcEFyZ3MpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIG9wdHMgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRNZW1vT3B0aW9ucyh0YWJsZU9wdGlvbnMsIGRlYnVnTGV2ZWwsIGtleSwgb25DaGFuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZU9wdGlvbnMkZGVidWdBbDtcbiAgICAgIHJldHVybiAoX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsID0gdGFibGVPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZU9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGVPcHRpb25zJGRlYnVnQWwgOiB0YWJsZU9wdGlvbnNbZGVidWdMZXZlbF07XG4gICAgfSxcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGtleSxcbiAgICBvbkNoYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uSWQpIHtcbiAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgdmFyIF9jZWxsJGdldFZhbHVlO1xuICAgIHJldHVybiAoX2NlbGwkZ2V0VmFsdWUgPSBjZWxsLmdldFZhbHVlKCkpICE9IG51bGwgPyBfY2VsbCRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgfTtcbiAgY29uc3QgY2VsbCA9IHtcbiAgICBpZDogYCR7cm93LmlkfV8ke2NvbHVtbi5pZH1gLFxuICAgIHJvdyxcbiAgICBjb2x1bW4sXG4gICAgZ2V0VmFsdWU6ICgpID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCksXG4gICAgcmVuZGVyVmFsdWU6IGdldFJlbmRlclZhbHVlLFxuICAgIGdldENvbnRleHQ6IG1lbW8oKCkgPT4gW3RhYmxlLCBjb2x1bW4sIHJvdywgY2VsbF0sICh0YWJsZSwgY29sdW1uLCByb3csIGNlbGwpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIGNlbGw6IGNlbGwsXG4gICAgICBnZXRWYWx1ZTogY2VsbC5nZXRWYWx1ZSxcbiAgICAgIHJlbmRlclZhbHVlOiBjZWxsLnJlbmRlclZhbHVlXG4gICAgfSksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NlbGxzJywgJ2NlbGwuZ2V0Q29udGV4dCcpKVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNlbGwgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNlbGwoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKTtcbiAgfSwge30pO1xuICByZXR1cm4gY2VsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpIHtcbiAgdmFyIF9yZWYsIF9yZXNvbHZlZENvbHVtbkRlZiRpZDtcbiAgY29uc3QgZGVmYXVsdENvbHVtbiA9IHRhYmxlLl9nZXREZWZhdWx0Q29sdW1uRGVmKCk7XG4gIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0ge1xuICAgIC4uLmRlZmF1bHRDb2x1bW4sXG4gICAgLi4uY29sdW1uRGVmXG4gIH07XG4gIGNvbnN0IGFjY2Vzc29yS2V5ID0gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gIGxldCBpZCA9IChfcmVmID0gKF9yZXNvbHZlZENvbHVtbkRlZiRpZCA9IHJlc29sdmVkQ29sdW1uRGVmLmlkKSAhPSBudWxsID8gX3Jlc29sdmVkQ29sdW1uRGVmJGlkIDogYWNjZXNzb3JLZXkgPyBhY2Nlc3NvcktleS5yZXBsYWNlKCcuJywgJ18nKSA6IHVuZGVmaW5lZCkgIT0gbnVsbCA/IF9yZWYgOiB0eXBlb2YgcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyID09PSAnc3RyaW5nJyA/IHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA6IHVuZGVmaW5lZDtcbiAgbGV0IGFjY2Vzc29yRm47XG4gIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgYWNjZXNzb3JGbiA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm47XG4gIH0gZWxzZSBpZiAoYWNjZXNzb3JLZXkpIHtcbiAgICAvLyBTdXBwb3J0IGRlZXAgYWNjZXNzb3Iga2V5c1xuICAgIGlmIChhY2Nlc3NvcktleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxSb3c7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY2Vzc29yS2V5LnNwbGl0KCcuJykpIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDtcbiAgICAgICAgICByZXN1bHQgPSAoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHRba2V5XTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIiR7a2V5fVwiIGluIGRlZXBseSBuZXN0ZWQga2V5IFwiJHthY2Nlc3NvcktleX1cIiByZXR1cm5lZCB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4gb3JpZ2luYWxSb3dbcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXldO1xuICAgIH1cbiAgfVxuICBpZiAoIWlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuID8gYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGFuIGFjY2Vzc29yRm5gIDogYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGEgbm9uLXN0cmluZyBoZWFkZXJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgbGV0IGNvbHVtbiA9IHtcbiAgICBpZDogYCR7U3RyaW5nKGlkKX1gLFxuICAgIGFjY2Vzc29yRm4sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgZGVwdGgsXG4gICAgY29sdW1uRGVmOiByZXNvbHZlZENvbHVtbkRlZixcbiAgICBjb2x1bW5zOiBbXSxcbiAgICBnZXRGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdHJ1ZV0sICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICByZXR1cm4gW2NvbHVtbiwgLi4uKChfY29sdW1uJGNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW4kY29sdW1ucy5mbGF0TWFwKGQgPT4gZC5nZXRGbGF0Q29sdW1ucygpKSldO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldEZsYXRDb2x1bW5zJykpLFxuICAgIGdldExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIG9yZGVyQ29sdW1ucyA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zMjtcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zMiA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1uczIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NvbHVtbl07XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdjb2x1bW4uZ2V0TGVhZkNvbHVtbnMnKSlcbiAgfTtcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIHRhYmxlLl9mZWF0dXJlcykge1xuICAgIGZlYXR1cmUuY3JlYXRlQ29sdW1uID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDb2x1bW4oY29sdW1uLCB0YWJsZSk7XG4gIH1cblxuICAvLyBZZXMsIHdlIGhhdmUgdG8gY29udmVydCB0YWJsZSB0byB1bmtub3duLCBiZWNhdXNlIHdlIGtub3cgbW9yZSB0aGFuIHRoZSBjb21waWxlciBoZXJlLlxuICByZXR1cm4gY29sdW1uO1xufVxuXG5jb25zdCBkZWJ1ZyA9ICdkZWJ1Z0hlYWRlcnMnO1xuLy9cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGlkO1xuICBjb25zdCBpZCA9IChfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQpICE9IG51bGwgPyBfb3B0aW9ucyRpZCA6IGNvbHVtbi5pZDtcbiAgbGV0IGhlYWRlciA9IHtcbiAgICBpZCxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgaXNQbGFjZWhvbGRlcjogISFvcHRpb25zLmlzUGxhY2Vob2xkZXIsXG4gICAgcGxhY2Vob2xkZXJJZDogb3B0aW9ucy5wbGFjZWhvbGRlcklkLFxuICAgIGRlcHRoOiBvcHRpb25zLmRlcHRoLFxuICAgIHN1YkhlYWRlcnM6IFtdLFxuICAgIGNvbFNwYW46IDAsXG4gICAgcm93U3BhbjogMCxcbiAgICBoZWFkZXJHcm91cDogbnVsbCxcbiAgICBnZXRMZWFmSGVhZGVyczogKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkhlYWRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJlY3Vyc2VIZWFkZXIgPSBoID0+IHtcbiAgICAgICAgaWYgKGguc3ViSGVhZGVycyAmJiBoLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaC5zdWJIZWFkZXJzLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFmSGVhZGVycy5wdXNoKGgpO1xuICAgICAgfTtcbiAgICAgIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgY29sdW1uXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVIZWFkZXIgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUhlYWRlcihoZWFkZXIsIHRhYmxlKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXI7XG59XG5jb25zdCBIZWFkZXJzID0ge1xuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIC8vIEhlYWRlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlciwgX3JpZ2h0JG1hcCRmaWx0ZXI7XG4gICAgICBjb25zdCBsZWZ0Q29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgcmlnaHRDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgY2VudGVyQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgY29uc3QgaGVhZGVyR3JvdXBzID0gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgWy4uLmxlZnRDb2x1bW5zLCAuLi5jZW50ZXJDb2x1bW5zLCAuLi5yaWdodENvbHVtbnNdLCB0YWJsZSk7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0SGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVySGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAnbGVmdCcpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfcmlnaHQkbWFwJGZpbHRlcjI7XG4gICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAncmlnaHQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJykpO1xuXG4gICAgLy8gRm9vdGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0Rm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZvb3Rlckdyb3VwcycpKTtcblxuICAgIC8vIEZsYXQgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0RmxhdEhlYWRlcnMnKSk7XG5cbiAgICAvLyBMZWFmIEhlYWRlcnNcblxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVycztcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVycyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVycy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczI7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0TGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkMCRoZWFkZXJzLCBfbGVmdCQsIF9jZW50ZXIkMCRoZWFkZXJzLCBfY2VudGVyJCwgX3JpZ2h0JDAkaGVhZGVycywgX3JpZ2h0JDtcbiAgICAgIHJldHVybiBbLi4uKChfbGVmdCQwJGhlYWRlcnMgPSAoX2xlZnQkID0gbGVmdFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZWZ0JC5oZWFkZXJzKSAhPSBudWxsID8gX2xlZnQkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9jZW50ZXIkMCRoZWFkZXJzID0gKF9jZW50ZXIkID0gY2VudGVyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NlbnRlciQuaGVhZGVycykgIT0gbnVsbCA/IF9jZW50ZXIkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9yaWdodCQwJGhlYWRlcnMgPSAoX3JpZ2h0JCA9IHJpZ2h0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3JpZ2h0JC5oZWFkZXJzKSAhPSBudWxsID8gX3JpZ2h0JDAkaGVhZGVycyA6IFtdKV0ubWFwKGhlYWRlciA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKTtcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlYWZIZWFkZXJzJykpO1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgY29sdW1uc1RvR3JvdXAsIHRhYmxlLCBoZWFkZXJGYW1pbHkpIHtcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XG4gIC8vIEZpbmQgdGhlIG1heCBkZXB0aCBvZiB0aGUgY29sdW1uczpcbiAgLy8gYnVpbGQgdGhlIGxlYWYgY29sdW1uIHJvd1xuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcbiAgLy8gICAgcGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBsZXZlbFxuICAvLyAgICByZWFsIGNvbHVtbiBmb3IgZXhpc3RpbmcgbGV2ZWxcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBjb25zdCBmaW5kTWF4RGVwdGggPSBmdW5jdGlvbiAoY29sdW1ucywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUoKSkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKTtcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChoZWFkZXJzVG9Hcm91cCwgZGVwdGgpID0+IHtcbiAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfTtcblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVycyA9IFtdO1xuXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xuICAgIGhlYWRlcnNUb0dyb3VwLmZvckVhY2goaGVhZGVyVG9Hcm91cCA9PiB7XG4gICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG5cbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPSBbLi4ucGVuZGluZ1BhcmVudEhlYWRlcnNdLnJldmVyc2UoKVswXTtcbiAgICAgIGNvbnN0IGlzTGVhZkhlYWRlciA9IGhlYWRlclRvR3JvdXAuY29sdW1uLmRlcHRoID09PSBoZWFkZXJHcm91cC5kZXB0aDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgaXNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uO1xuICAgICAgICBpc1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLmNvbHVtbikgPT09IGNvbHVtbikge1xuICAgICAgICAvLyBUaGlzIGNvbHVtbiBpcyByZXBlYXRlZC4gQWRkIGl0IGFzIGEgc3ViIGhlYWRlciB0byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cCA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVyVG9Hcm91cC5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgICAgICBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBpbmRleDogcGVuZGluZ1BhcmVudEhlYWRlcnMubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyVG9Hcm91cCBhcyBhIHN1YkhlYWRlciBvZiB0aGUgbmV3IGhlYWRlclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlckdyb3VwLmhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcbiAgICB9KTtcbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cCk7XG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgY3JlYXRlSGVhZGVyR3JvdXAocGVuZGluZ1BhcmVudEhlYWRlcnMsIGRlcHRoIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBib3R0b21IZWFkZXJzID0gY29sdW1uc1RvR3JvdXAubWFwKChjb2x1bW4sIGluZGV4KSA9PiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgIGRlcHRoOiBtYXhEZXB0aCxcbiAgICBpbmRleFxuICB9KSk7XG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSk7XG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnMubWFwKGhlYWRlciA9PiB7XG4gICAgICBsZXQgY29sU3BhbiA9IDA7XG4gICAgICBsZXQgcm93U3BhbiA9IDA7XG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXTtcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGRSb3dTcGFucyA9IFtdO1xuICAgICAgICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKGhlYWRlci5zdWJIZWFkZXJzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb2xTcGFuOiBjaGlsZENvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjaGlsZFJvd1NwYW5cbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBjb2xTcGFuICs9IGNoaWxkQ29sU3BhbjtcbiAgICAgICAgICBjaGlsZFJvd1NwYW5zLnB1c2goY2hpbGRSb3dTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkNoaWxkUm93U3BhbiA9IE1hdGgubWluKC4uLmNoaWxkUm93U3BhbnMpO1xuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW47XG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKChfaGVhZGVyR3JvdXBzJDAkaGVhZGUgPSAoX2hlYWRlckdyb3VwcyQgPSBoZWFkZXJHcm91cHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyR3JvdXBzJC5oZWFkZXJzKSAhPSBudWxsID8gX2hlYWRlckdyb3VwcyQwJGhlYWRlIDogW10pO1xuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xufVxuXG5jb25zdCBjcmVhdGVSb3cgPSAodGFibGUsIGlkLCBvcmlnaW5hbCwgcm93SW5kZXgsIGRlcHRoLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4ge1xuICBsZXQgcm93ID0ge1xuICAgIGlkLFxuICAgIGluZGV4OiByb3dJbmRleCxcbiAgICBvcmlnaW5hbCxcbiAgICBkZXB0aCxcbiAgICBwYXJlbnRJZCxcbiAgICBfdmFsdWVzQ2FjaGU6IHt9LFxuICAgIF91bmlxdWVWYWx1ZXNDYWNoZToge30sXG4gICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5hY2Nlc3NvckZuKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlVmFsdWVzOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll91bmlxdWVWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IFtyb3cuZ2V0VmFsdWUoY29sdW1uSWQpXTtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyhyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIHJlbmRlclZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfcm93JGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICAgIH0sXG4gICAgc3ViUm93czogc3ViUm93cyAhPSBudWxsID8gc3ViUm93cyA6IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBmbGF0dGVuQnkocm93LnN1YlJvd3MsIGQgPT4gZC5zdWJSb3dzKSxcbiAgICBnZXRQYXJlbnRSb3c6ICgpID0+IHJvdy5wYXJlbnRJZCA/IHRhYmxlLmdldFJvdyhyb3cucGFyZW50SWQsIHRydWUpIDogdW5kZWZpbmVkLFxuICAgIGdldFBhcmVudFJvd3M6ICgpID0+IHtcbiAgICAgIGxldCBwYXJlbnRSb3dzID0gW107XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJvdyA9IGN1cnJlbnRSb3cuZ2V0UGFyZW50Um93KCk7XG4gICAgICAgIGlmICghcGFyZW50Um93KSBicmVhaztcbiAgICAgICAgcGFyZW50Um93cy5wdXNoKHBhcmVudFJvdyk7XG4gICAgICAgIGN1cnJlbnRSb3cgPSBwYXJlbnRSb3c7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBnZXRBbGxDZWxsczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKV0sIGxlYWZDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW4uaWQpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxscycpKSxcbiAgICBfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkOiBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKV0sIGFsbENlbGxzID0+IHtcbiAgICAgIHJldHVybiBhbGxDZWxscy5yZWR1Y2UoKGFjYywgY2VsbCkgPT4ge1xuICAgICAgICBhY2NbY2VsbC5jb2x1bW4uaWRdID0gY2VsbDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEFsbENlbGxzQnlDb2x1bW5JZCcpKVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93ID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cocm93LCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn07XG5cbi8vXG5cbmNvbnN0IENvbHVtbkZhY2V0aW5nID0ge1xuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGluY2x1ZGVzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvU3RyaW5nKCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvTG93ZXJDYXNlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlLmluY2x1ZGVzKHNlYXJjaCkpO1xufTtcbmluY2x1ZGVzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUyO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZTIgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMiA9IF9yb3ckZ2V0VmFsdWUyLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMi5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkpO1xufTtcbmluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgZXF1YWxzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMztcbiAgcmV0dXJuICgoX3JvdyRnZXRWYWx1ZTMgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMyA9IF9yb3ckZ2V0VmFsdWUzLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMy50b0xvd2VyQ2FzZSgpKSA9PT0gKGZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5lcXVhbHNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBhcnJJbmNsdWRlcyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTQ7XG4gIHJldHVybiAoX3JvdyRnZXRWYWx1ZTQgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTQuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xufTtcbmFyckluY2x1ZGVzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc0FsbCA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XG4gICAgcmV0dXJuICEoKF9yb3ckZ2V0VmFsdWU1ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCAmJiBfcm93JGdldFZhbHVlNS5pbmNsdWRlcyh2YWwpKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNBbGwuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzU29tZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNjtcbiAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU2ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU2LmluY2x1ZGVzKHZhbCk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09PSBmaWx0ZXJWYWx1ZTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCB3ZWFrRXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlO1xufTtcbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbk51bWJlclJhbmdlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XG4gIGNvbnN0IHJvd1ZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG59O1xuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSB2YWwgPT4ge1xuICBsZXQgW3Vuc2FmZU1pbiwgdW5zYWZlTWF4XSA9IHZhbDtcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xuICBsZXQgcGFyc2VkTWF4ID0gdHlwZW9mIHVuc2FmZU1heCAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1heCkgOiB1bnNhZmVNYXg7XG4gIGxldCBtaW4gPSB1bnNhZmVNaW4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1pbikgPyAtSW5maW5pdHkgOiBwYXJzZWRNaW47XG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuaW5OdW1iZXJSYW5nZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCB0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pO1xuXG4vLyBFeHBvcnRcblxuY29uc3QgZmlsdGVyRm5zID0ge1xuICBpbmNsdWRlc1N0cmluZyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUsXG4gIGVxdWFsc1N0cmluZyxcbiAgYXJySW5jbHVkZXMsXG4gIGFyckluY2x1ZGVzQWxsLFxuICBhcnJJbmNsdWRlc1NvbWUsXG4gIGVxdWFscyxcbiAgd2Vha0VxdWFscyxcbiAgaW5OdW1iZXJSYW5nZVxufTtcbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIHRlc3RGYWxzZXkodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnJztcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uRmlsdGVyaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlckZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uRmlsdGVyczogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIGZpbHRlckZyb21MZWFmUm93czogZmFsc2UsXG4gICAgICBtYXhMZWFmUm93RmlsdGVyRGVwdGg6IDEwMFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbk51bWJlclJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5hcnJJbmNsdWRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFscztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gOiBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyID0gKF90YWJsZSRvcHRpb25zJGZpbHRlcjIgPSB0YWJsZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGZpbHRlcjJbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzRmlsdGVyZWQgPSAoKSA9PiBjb2x1bW4uZ2V0RmlsdGVySW5kZXgoKSA+IC0xO1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtLnZhbHVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMob2xkID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNGaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgcHJldmlvdXNGaWx0ZXIgPyBwcmV2aW91c0ZpbHRlci52YWx1ZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICAgIHZhciBfb2xkJGZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF9vbGQkZmlsdGVyIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RmlsdGVyT2JqID0ge1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgdmFsdWU6IG5ld0ZpbHRlclxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJldmlvdXNGaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgX29sZCRtYXA7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJG1hcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pKSAhPSBudWxsID8gX29sZCRtYXAgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbLi4ub2xkLCBuZXdGaWx0ZXJPYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3RmlsdGVyT2JqXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgX3RhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzID0gdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCk7XG4gICAgICBjb25zdCB1cGRhdGVGbiA9IG9sZCA9PiB7XG4gICAgICAgIHZhciBfZnVuY3Rpb25hbFVwZGF0ZTtcbiAgICAgICAgcmV0dXJuIChfZnVuY3Rpb25hbFVwZGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mdW5jdGlvbmFsVXBkYXRlLmZpbHRlcihmaWx0ZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBmaWx0ZXIuaWQpO1xuICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgZmlsdGVyLnZhbHVlLCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UodXBkYXRlRm4pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgdmFsdWUsIGNvbHVtbikge1xuICByZXR1cm4gKGZpbHRlckZuICYmIGZpbHRlckZuLmF1dG9SZW1vdmUgPyBmaWx0ZXJGbi5hdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogZmFsc2UpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhdmFsdWU7XG59XG5cbmNvbnN0IHN1bSA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgLy8gSXQncyBmYXN0ZXIgdG8ganVzdCBhZGQgdGhlIGFnZ3JlZ2F0aW9ucyB0b2dldGhlciBpbnN0ZWFkIG9mXG4gIC8vIHByb2Nlc3MgbGVhZiBub2RlcyBpbmRpdmlkdWFsbHlcbiAgcmV0dXJuIGNoaWxkUm93cy5yZWR1Y2UoKHN1bSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHQuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHRWYWx1ZSA9PT0gJ251bWJlcicgPyBuZXh0VmFsdWUgOiAwKTtcbiAgfSwgMCk7XG59O1xuY29uc3QgbWluID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWluID4gdmFsdWUgfHwgbWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtaW4gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluO1xufTtcbmNvbnN0IG1heCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1heCA8IHZhbHVlIHx8IG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWF4ID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1heDtcbn07XG5jb25zdCBleHRlbnQgPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuY29uc3QgbWVhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGxlYWZSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBsZXQgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICsrY291bnQsIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudDtcbiAgcmV0dXJuO1xufTtcbmNvbnN0IG1lZGlhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgaWYgKCFsZWFmUm93cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gbGVhZlJvd3MubWFwKHJvdyA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbiAgaWYgKCFpc051bWJlckFycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICBjb25zdCBudW1zID0gdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbn07XG5jb25zdCB1bmlxdWUgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS52YWx1ZXMoKSk7XG59O1xuY29uc3QgdW5pcXVlQ291bnQgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkuc2l6ZTtcbn07XG5jb25zdCBjb3VudCA9IChfY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBsZWFmUm93cy5sZW5ndGg7XG59O1xuY29uc3QgYWdncmVnYXRpb25GbnMgPSB7XG4gIHN1bSxcbiAgbWluLFxuICBtYXgsXG4gIGV4dGVudCxcbiAgbWVhbixcbiAgbWVkaWFuLFxuICB1bmlxdWUsXG4gIHVuaXF1ZUNvdW50LFxuICBjb3VudFxufTtcblxuLy9cblxuY29uc3QgQ29sdW1uR3JvdXBpbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYWdncmVnYXRlZENlbGw6IHByb3BzID0+IHtcbiAgICAgICAgdmFyIF90b1N0cmluZywgX3Byb3BzJGdldFZhbHVlO1xuICAgICAgICByZXR1cm4gKF90b1N0cmluZyA9IChfcHJvcHMkZ2V0VmFsdWUgPSBwcm9wcy5nZXRWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfdG9TdHJpbmcgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFnZ3JlZ2F0aW9uRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBncm91cGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uR3JvdXBpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dyb3VwaW5nJywgdGFibGUpLFxuICAgICAgZ3JvdXBlZENvbHVtbk1vZGU6ICdyZW9yZGVyJ1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBncm91cGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZC5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uKG9sZCAhPSBudWxsID8gb2xkIDogW10pLCBjb2x1bW4uaWRdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR3JvdXAgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3JlZjIsIF9yZWYzLCBfY29sdW1uJGNvbHVtbkRlZiRlbmE7XG4gICAgICByZXR1cm4gKF9yZWYgPSAoX3JlZjIgPSAoX3JlZjMgPSAoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICE9IG51bGwgPyBfcmVmMyA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfcmVmMiA6IHRydWUpICE9IG51bGwgPyBfcmVmIDogISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc0dyb3VwZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAgPSB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGdyb3VwLmluY2x1ZGVzKGNvbHVtbi5pZCk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0R3JvdXBlZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRncm91cDI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cDIgPSB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGdyb3VwMi5pbmRleE9mKGNvbHVtbi5pZCk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuR3JvdXAgPSBjb2x1bW4uZ2V0Q2FuR3JvdXAoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuR3JvdXApIHJldHVybjtcbiAgICAgICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYWdncmVnYXRpb25GbnMuc3VtO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICByZXR1cm4gYWdncmVnYXRpb25GbnMuZXh0ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkYWdncmVnLCBfdGFibGUkb3B0aW9ucyRhZ2dyZWcyO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4pID8gY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuIDogY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4oKSA6IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcgPSAoX3RhYmxlJG9wdGlvbnMkYWdncmVnMiA9IHRhYmxlLm9wdGlvbnMuYWdncmVnYXRpb25GbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRhZ2dyZWcyW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhZ2dyZWcgOiBhZ2dyZWdhdGlvbkZuc1tjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0R3JvdXBpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0R3JvdXBpbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkZywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkZyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5ncm91cGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkZyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEdyb3VwaW5nIHx8ICF0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5nZXRJc0dyb3VwZWQgPSAoKSA9PiAhIXJvdy5ncm91cGluZ0NvbHVtbklkO1xuICAgIHJvdy5nZXRHcm91cGluZ1ZhbHVlID0gY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICAgIH1cbiAgICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUocm93Lm9yaWdpbmFsKTtcbiAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH07XG4gICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlID0ge307XG4gIH0sXG4gIGNyZWF0ZUNlbGw6IChjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUpID0+IHtcbiAgICBjZWxsLmdldElzR3JvdXBlZCA9ICgpID0+IGNvbHVtbi5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uaWQgPT09IHJvdy5ncm91cGluZ0NvbHVtbklkO1xuICAgIGNlbGwuZ2V0SXNQbGFjZWhvbGRlciA9ICgpID0+ICFjZWxsLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5nZXRJc0dyb3VwZWQoKTtcbiAgICBjZWxsLmdldElzQWdncmVnYXRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgIWNlbGwuZ2V0SXNQbGFjZWhvbGRlcigpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgaWYgKCEoZ3JvdXBpbmcgIT0gbnVsbCAmJiBncm91cGluZy5sZW5ndGgpIHx8ICFncm91cGVkQ29sdW1uTW9kZSkge1xuICAgIHJldHVybiBsZWFmQ29sdW1ucztcbiAgfVxuICBjb25zdCBub25Hcm91cGluZ0NvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sID0+ICFncm91cGluZy5pbmNsdWRlcyhjb2wuaWQpKTtcbiAgaWYgKGdyb3VwZWRDb2x1bW5Nb2RlID09PSAncmVtb3ZlJykge1xuICAgIHJldHVybiBub25Hcm91cGluZ0NvbHVtbnM7XG4gIH1cbiAgY29uc3QgZ3JvdXBpbmdDb2x1bW5zID0gZ3JvdXBpbmcubWFwKGcgPT4gbGVhZkNvbHVtbnMuZmluZChjb2wgPT4gY29sLmlkID09PSBnKSkuZmlsdGVyKEJvb2xlYW4pO1xuICByZXR1cm4gWy4uLmdyb3VwaW5nQ29sdW1ucywgLi4ubm9uR3JvdXBpbmdDb2x1bW5zXTtcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uT3JkZXJpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5PcmRlcjogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uT3JkZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtbk9yZGVyJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRJbmRleCA9IG1lbW8ocG9zaXRpb24gPT4gW19nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKV0sIGNvbHVtbnMgPT4gY29sdW1ucy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEluZGV4JykpO1xuICAgIGNvbHVtbi5nZXRJc0ZpcnN0Q29sdW1uID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9jb2x1bW5zJDtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gKChfY29sdW1ucyQgPSBjb2x1bW5zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbnMkLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzTGFzdENvbHVtbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfY29sdW1ucztcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gKChfY29sdW1ucyA9IGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW5zLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uT3JkZXIgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uT3JkZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtbk9yZGVyKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbiA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuY29sdW1uT3JkZXIsIHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLm9wdGlvbnMuZ3JvdXBlZENvbHVtbk1vZGVdLCAoY29sdW1uT3JkZXIsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkgPT4gY29sdW1ucyA9PiB7XG4gICAgICAvLyBTb3J0IGdyb3VwZWQgY29sdW1ucyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbHVtbiBsaXN0XG4gICAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XG4gICAgICBsZXQgb3JkZXJlZENvbHVtbnMgPSBbXTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb3JkZXIsIHJldHVybiB0aGUgbm9ybWFsIGNvbHVtbnNcbiAgICAgIGlmICghKGNvbHVtbk9yZGVyICE9IG51bGwgJiYgY29sdW1uT3JkZXIubGVuZ3RoKSkge1xuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2x1bW5PcmRlckNvcHkgPSBbLi4uY29sdW1uT3JkZXJdO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xuICAgICAgICBjb25zdCBjb2x1bW5zQ29weSA9IFsuLi5jb2x1bW5zXTtcblxuICAgICAgICAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuICAgICAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW5JZCA9IGNvbHVtbk9yZGVyQ29weS5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kSW5kZXggPSBjb2x1bW5zQ29weS5maW5kSW5kZXgoZCA9PiBkLmlkID09PSB0YXJnZXRDb2x1bW5JZCk7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgb3JkZXJlZENvbHVtbnMucHVzaChjb2x1bW5zQ29weS5zcGxpY2UoZm91bmRJbmRleCwgMSlbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgY29sdW1ucyBsZWZ0LCBhZGQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gWy4uLm9yZGVyZWRDb2x1bW5zLCAuLi5jb2x1bW5zQ29weV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKG9yZGVyZWRDb2x1bW5zLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ19nZXRPcmRlckNvbHVtbnNGbicpKTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSA9ICgpID0+ICh7XG4gIGxlZnQ6IFtdLFxuICByaWdodDogW11cbn0pO1xuY29uc3QgQ29sdW1uUGlubmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblBpbm5pbmc6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5QaW5uaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5QaW5uaW5nJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5waW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5JZHMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb2xkJGxlZnQzLCBfb2xkJHJpZ2h0MztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdCwgX29sZCRyaWdodDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgICByaWdodDogWy4uLigoX29sZCRyaWdodCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQyLCBfb2xkJHJpZ2h0MjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogWy4uLigoX29sZCRsZWZ0MiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc10sXG4gICAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MyA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MyA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpO1xuICAgICAgcmV0dXJuIGxlYWZDb2x1bW5zLnNvbWUoZCA9PiB7XG4gICAgICAgIHZhciBfZCRjb2x1bW5EZWYkZW5hYmxlUGksIF9yZWYsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgICAgcmV0dXJuICgoX2QkY29sdW1uRGVmJGVuYWJsZVBpID0gZC5jb2x1bW5EZWYuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9kJGNvbHVtbkRlZiRlbmFibGVQaSA6IHRydWUpICYmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0YWJsZS5vcHRpb25zLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfcmVmIDogdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5JZHMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5tYXAoZCA9PiBkLmlkKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmc7XG4gICAgICBjb25zdCBpc0xlZnQgPSBsZWFmQ29sdW1uSWRzLnNvbWUoZCA9PiBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0LmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzUmlnaHQgPSBsZWFmQ29sdW1uSWRzLnNvbWUoZCA9PiByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQuaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzTGVmdCA/ICdsZWZ0JyA6IGlzUmlnaHQgPyAncmlnaHQnIDogZmFsc2U7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0yO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb2x1bW4uZ2V0SXNQaW5uZWQoKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA/IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTJbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMi5pbmRleE9mKGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0gOiAtMSA6IDA7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDZWxscy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuY29sdW1uLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRDZW50ZXJWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDZWxscywgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ2xlZnQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRMZWZ0VmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRSaWdodFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0UmlnaHRWaXNpYmxlQ2VsbHMnKSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uUGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldENvbHVtblBpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRsZWZ0LCBfcGlubmluZ1N0YXRlJHJpZ2h0O1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkbGVmdCA9IHBpbm5pbmdTdGF0ZS5sZWZ0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRsZWZ0Lmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJHJpZ2h0ID0gcGlubmluZ1N0YXRlLnJpZ2h0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRyaWdodC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWZ0KSA9PiB7XG4gICAgICByZXR1cm4gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldExlZnRMZWFmQ29sdW1ucycpKTtcbiAgICB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICByZXR1cm4gKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0UmlnaHRMZWFmQ29sdW1ucycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldENlbnRlckxlYWZDb2x1bW5zJykpO1xuICB9XG59O1xuXG4vL1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0Q29sdW1uU2l6aW5nID0ge1xuICBzaXplOiAxNTAsXG4gIG1pblNpemU6IDIwLFxuICBtYXhTaXplOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxufTtcbmNvbnN0IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUgPSAoKSA9PiAoe1xuICBzdGFydE9mZnNldDogbnVsbCxcbiAgc3RhcnRTaXplOiBudWxsLFxuICBkZWx0YU9mZnNldDogbnVsbCxcbiAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG59KTtcbmNvbnN0IENvbHVtblNpemluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiBkZWZhdWx0Q29sdW1uU2l6aW5nO1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uU2l6aW5nOiB7fSxcbiAgICAgIGNvbHVtblNpemluZ0luZm86IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUmVzaXplTW9kZTogJ29uRW5kJyxcbiAgICAgIGNvbHVtblJlc2l6ZURpcmVjdGlvbjogJ2x0cicsXG4gICAgICBvbkNvbHVtblNpemluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nJywgdGFibGUpLFxuICAgICAgb25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmdJbmZvJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJG1pbiwgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkbWF4O1xuICAgICAgY29uc3QgY29sdW1uU2l6ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nW2NvbHVtbi5pZF07XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoKF9jb2x1bW4kY29sdW1uRGVmJG1pbiA9IGNvbHVtbi5jb2x1bW5EZWYubWluU2l6ZSkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJG1pbiA6IGRlZmF1bHRDb2x1bW5TaXppbmcubWluU2l6ZSwgKF9yZWYgPSBjb2x1bW5TaXplICE9IG51bGwgPyBjb2x1bW5TaXplIDogY29sdW1uLmNvbHVtbkRlZi5zaXplKSAhPSBudWxsID8gX3JlZiA6IGRlZmF1bHRDb2x1bW5TaXppbmcuc2l6ZSksIChfY29sdW1uJGNvbHVtbkRlZiRtYXggPSBjb2x1bW4uY29sdW1uRGVmLm1heFNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtYXggOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1heFNpemUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFN0YXJ0ID0gbWVtbyhwb3NpdGlvbiA9PiBbcG9zaXRpb24sIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmddLCAocG9zaXRpb24sIGNvbHVtbnMpID0+IGNvbHVtbnMuc2xpY2UoMCwgY29sdW1uLmdldEluZGV4KHBvc2l0aW9uKSkucmVkdWNlKChzdW0sIGNvbHVtbikgPT4gc3VtICsgY29sdW1uLmdldFNpemUoKSwgMCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0U3RhcnQnKSk7XG4gICAgY29sdW1uLmdldEFmdGVyID0gbWVtbyhwb3NpdGlvbiA9PiBbcG9zaXRpb24sIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmddLCAocG9zaXRpb24sIGNvbHVtbnMpID0+IGNvbHVtbnMuc2xpY2UoY29sdW1uLmdldEluZGV4KHBvc2l0aW9uKSArIDEpLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFmdGVyJykpO1xuICAgIGNvbHVtbi5yZXNldFNpemUgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIFtjb2x1bW4uaWRdOiBfLFxuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlUmVzaXppbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUmVzaXppbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Jlc2l6aW5nID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlSGVhZGVyOiAoaGVhZGVyLCB0YWJsZSkgPT4ge1xuICAgIGhlYWRlci5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBjb25zdCByZWN1cnNlID0gaGVhZGVyID0+IHtcbiAgICAgICAgaWYgKGhlYWRlci5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlci5zdWJIZWFkZXJzLmZvckVhY2gocmVjdXJzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9oZWFkZXIkY29sdW1uJGdldFNpejtcbiAgICAgICAgICBzdW0gKz0gKF9oZWFkZXIkY29sdW1uJGdldFNpeiA9IGhlYWRlci5jb2x1bW4uZ2V0U2l6ZSgpKSAhPSBudWxsID8gX2hlYWRlciRjb2x1bW4kZ2V0U2l6IDogMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlY3Vyc2UoaGVhZGVyKTtcbiAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgICBoZWFkZXIuZ2V0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGVhZGVyLmluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZ0hlYWRlciA9IGhlYWRlci5oZWFkZXJHcm91cC5oZWFkZXJzW2hlYWRlci5pbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdIZWFkZXIuZ2V0U3RhcnQoKSArIHByZXZTaWJsaW5nSGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFJlc2l6ZUhhbmRsZXIgPSBfY29udGV4dERvY3VtZW50ID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihoZWFkZXIuY29sdW1uLmlkKTtcbiAgICAgIGNvbnN0IGNhblJlc2l6ZSA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldENhblJlc2l6ZSgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCAhY2FuUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcbiAgICAgICAgICAvLyBsZXRzIG5vdCByZXNwb25kIHRvIG11bHRpcGxlIHRvdWNoZXMgKGUuZy4gMiBvciAzIGZpbmdlcnMpXG4gICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgICBjb25zdCBjb2x1bW5TaXppbmdTdGFydCA9IGhlYWRlciA/IGhlYWRlci5nZXRMZWFmSGVhZGVycygpLm1hcChkID0+IFtkLmNvbHVtbi5pZCwgZC5jb2x1bW4uZ2V0U2l6ZSgpXSkgOiBbW2NvbHVtbi5pZCwgY29sdW1uLmdldFNpemUoKV1dO1xuICAgICAgICBjb25zdCBjbGllbnRYID0gaXNUb3VjaFN0YXJ0RXZlbnQoZSkgPyBNYXRoLnJvdW5kKGUudG91Y2hlc1swXS5jbGllbnRYKSA6IGUuY2xpZW50WDtcbiAgICAgICAgY29uc3QgbmV3Q29sdW1uU2l6aW5nID0ge307XG4gICAgICAgIGNvbnN0IHVwZGF0ZU9mZnNldCA9IChldmVudFR5cGUsIGNsaWVudFhQb3MpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudFhQb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+IHtcbiAgICAgICAgICAgIHZhciBfb2xkJHN0YXJ0T2Zmc2V0LCBfb2xkJHN0YXJ0U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhRGlyZWN0aW9uID0gdGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVEaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSAoY2xpZW50WFBvcyAtICgoX29sZCRzdGFydE9mZnNldCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0T2Zmc2V0KSAhPSBudWxsID8gX29sZCRzdGFydE9mZnNldCA6IDApKSAqIGRlbHRhRGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFQZXJjZW50YWdlID0gTWF0aC5tYXgoZGVsdGFPZmZzZXQgLyAoKF9vbGQkc3RhcnRTaXplID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuc3RhcnRTaXplKSAhPSBudWxsID8gX29sZCRzdGFydFNpemUgOiAwKSwgLTAuOTk5OTk5KTtcbiAgICAgICAgICAgIG9sZC5jb2x1bW5TaXppbmdTdGFydC5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgICAgICAgICAgbGV0IFtjb2x1bW5JZCwgaGVhZGVyU2l6ZV0gPSBfcmVmMztcbiAgICAgICAgICAgICAgbmV3Q29sdW1uU2l6aW5nW2NvbHVtbklkXSA9IE1hdGgucm91bmQoTWF0aC5tYXgoaGVhZGVyU2l6ZSArIGhlYWRlclNpemUgKiBkZWx0YVBlcmNlbnRhZ2UsIDApICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICBkZWx0YU9mZnNldCxcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgfHwgZXZlbnRUeXBlID09PSAnZW5kJykge1xuICAgICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKG9sZCA9PiAoe1xuICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgIC4uLm5ld0NvbHVtblNpemluZ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Nb3ZlID0gY2xpZW50WFBvcyA9PiB1cGRhdGVPZmZzZXQoJ21vdmUnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSBjbGllbnRYUG9zID0+IHtcbiAgICAgICAgICB1cGRhdGVPZmZzZXQoJ2VuZCcsIGNsaWVudFhQb3MpO1xuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgc3RhcnRTaXplOiBudWxsLFxuICAgICAgICAgICAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gICAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydDogW11cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHREb2N1bWVudCA9IF9jb250ZXh0RG9jdW1lbnQgfHwgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4gb25Nb3ZlKGUuY2xpZW50WCksXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBvbkVuZChlLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG91Y2hFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIHZhciBfZSR0b3VjaGVzJDtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkVuZCgoX2UkdG91Y2hlcyQgPSBlLnRvdWNoZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzJC5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IGNsaWVudFgsXG4gICAgICAgICAgc3RhcnRTaXplLFxuICAgICAgICAgIGRlbHRhT2Zmc2V0OiAwLFxuICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogMCxcbiAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW4uaWRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5TaXppbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRIZWFkZXJTaXplSW5mbyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjMjtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYzIgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nSW5mbykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYzIgOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRIZWFkZXJHcm91cCwgX3RhYmxlJGdldEhlYWRlckdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldEhlYWRlckdyb3VwID0gKF90YWJsZSRnZXRIZWFkZXJHcm91cDIgPSB0YWJsZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRIZWFkZXJHcm91cDIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0SGVhZGVyR3JvdXAgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0TGVmdEhlYWRlckcsIF90YWJsZSRnZXRMZWZ0SGVhZGVyRzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA9IChfdGFibGUkZ2V0TGVmdEhlYWRlckcyID0gdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldExlZnRIZWFkZXJHMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENlbnRlckhlYWRlLCBfdGFibGUkZ2V0Q2VudGVySGVhZGUyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q2VudGVySGVhZGUgPSAoX3RhYmxlJGdldENlbnRlckhlYWRlMiA9IHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENlbnRlckhlYWRlMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRDZW50ZXJIZWFkZSA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRSaWdodFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0UmlnaHRIZWFkZXIsIF90YWJsZSRnZXRSaWdodEhlYWRlcjI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRSaWdodEhlYWRlciA9IChfdGFibGUkZ2V0UmlnaHRIZWFkZXIyID0gdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRSaWdodEhlYWRlcjIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0UmlnaHRIZWFkZXIgOiAwO1xuICAgIH07XG4gIH1cbn07XG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IG51bGw7XG5mdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcGFzc2l2ZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoU3RhcnRFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jztcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uVmlzaWJpbGl0eSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblZpc2liaWxpdHk6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblZpc2liaWxpdHknLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAoY29sdW1uLmdldENhbkhpZGUoKSkge1xuICAgICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBbY29sdW1uLmlkXTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogIWNvbHVtbi5nZXRJc1Zpc2libGUoKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIGNvbnN0IGNoaWxkQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zO1xuICAgICAgcmV0dXJuIChfcmVmID0gY2hpbGRDb2x1bW5zLmxlbmd0aCA/IGNoaWxkQ29sdW1ucy5zb21lKGMgPT4gYy5nZXRJc1Zpc2libGUoKSkgOiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5KSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtW2NvbHVtbi5pZF0pICE9IG51bGwgPyBfcmVmIDogdHJ1ZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5IaWRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuX2dldEFsbFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLCBjZWxscyA9PiB7XG4gICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGNlbGwgPT4gY2VsbC5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnX2dldEFsbFZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgcm93LmdldENlbnRlclZpc2libGVDZWxscygpLCByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiBbLi4ubGVmdCwgLi4uY2VudGVyLCAuLi5yaWdodF0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0VmlzaWJsZUNlbGxzJykpO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGNvbnN0IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCA9IChrZXksIGdldENvbHVtbnMpID0+IHtcbiAgICAgIHJldHVybiBtZW1vKCgpID0+IFtnZXRDb2x1bW5zKCksIGdldENvbHVtbnMoKS5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSgpKS5tYXAoZCA9PiBkLmlkKS5qb2luKCdfJyldLCBjb2x1bW5zID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZ2V0SXNWaXNpYmxlKCkpO1xuICAgICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsIGtleSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VmlzaWJsZUZsYXRDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlRmxhdENvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldENlbnRlclZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblZpc2liaWxpdHkgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblZpc2liaWxpdHkpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSA9IHZhbHVlID0+IHtcbiAgICAgIHZhciBfdmFsdWU7XG4gICAgICB2YWx1ZSA9IChfdmFsdWUgPSB2YWx1ZSkgIT0gbnVsbCA/IF92YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlKCk7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkucmVkdWNlKChvYmosIGNvbHVtbikgPT4gKHtcbiAgICAgICAgLi4ub2JqLFxuICAgICAgICBbY29sdW1uLmlkXTogIXZhbHVlID8gIShjb2x1bW4uZ2V0Q2FuSGlkZSAhPSBudWxsICYmIGNvbHVtbi5nZXRDYW5IaWRlKCkpIDogdmFsdWVcbiAgICAgIH0pLCB7fSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSA9ICgpID0+ICF0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+ICEoY29sdW1uLmdldElzVmlzaWJsZSAhPSBudWxsICYmIGNvbHVtbi5nZXRJc1Zpc2libGUoKSkpO1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNWaXNpYmxlID0gKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuICFwb3NpdGlvbiA/IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpIDogcG9zaXRpb24gPT09ICdjZW50ZXInID8gdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucygpIDogdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMoKTtcbn1cblxuLy9cblxuY29uc3QgR2xvYmFsRmlsdGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2xvYmFsRmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uR2xvYmFsRmlsdGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdnbG9iYWxGaWx0ZXInLCB0YWJsZSksXG4gICAgICBnbG9iYWxGaWx0ZXJGbjogJ2F1dG8nLFxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJGdldENvcmVSb3dNb2RlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXSkgPT0gbnVsbCB8fCAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gX3RhYmxlJGdldENvcmVSb3dNb2RlLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVtjb2x1bW4uaWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvcmVSb3dNb2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTIsIF90YWJsZSRvcHRpb25zJGdldENvbDtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGdldENvbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlcihjb2x1bW4pKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Q29sIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdsb2JhbEZpbHRlckZuOiBnbG9iYWxGaWx0ZXJGblxuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihnbG9iYWxGaWx0ZXJGbikgPyBnbG9iYWxGaWx0ZXJGbiA6IGdsb2JhbEZpbHRlckZuID09PSAnYXV0bycgPyB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcbiAgICAgIChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltnbG9iYWxGaWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm5dO1xuICAgIH07XG4gICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0R2xvYmFsRmlsdGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlcihkZWZhdWx0U3RhdGUgPyB1bmRlZmluZWQgOiB0YWJsZS5pbml0aWFsU3RhdGUuZ2xvYmFsRmlsdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd0V4cGFuZGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGFuZGVkOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeHBhbmRlZENoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZXhwYW5kZWQnLCB0YWJsZSksXG4gICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93czogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRFeHBhbmRlZCA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRlLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRlID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmV4cGFuZGVkKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRlIDoge30pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhbkV4cGFuZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuXG4gICAgICAvLyBJZiBleHBhbmRlZCBpcyB0cnVlLCBzYXZlIHNvbWUgY3ljbGVzIGFuZCByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSByb3cgaXMgbm90IGV4cGFuZGVkLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmICh0YWJsZS5nZXRSb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3cuZ2V0SXNFeHBhbmRlZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xuICAgICAgbGV0IG1heERlcHRoID0gMDtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWUgPyBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKSA6IE9iamVjdC5rZXlzKHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQpO1xuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdElkID0gaWQuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nIHx8ICF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKG9sZCA9PiB7XG4gICAgICAgIHZhciBfZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XG4gICAgICAgIGxldCBvbGRFeHBhbmRlZCA9IHt9O1xuICAgICAgICBpZiAob2xkID09PSB0cnVlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICBvbGRFeHBhbmRlZFtyb3dJZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZEV4cGFuZGVkID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcbiAgICAgICAgaWYgKCFleGlzdHMgJiYgZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXG4gICAgICAgICAgICBbcm93LmlkXTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBbcm93LmlkXTogXyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gb2xkRXhwYW5kZWQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuICEhKChfdGFibGUkb3B0aW9ucyRnZXRJc1IgPSB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIDogZXhwYW5kZWQgPT09IHRydWUgfHwgKGV4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiBleHBhbmRlZFtyb3cuaWRdKSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuRXhwYW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAoaXNGdWxseUV4cGFuZGVkICYmIGN1cnJlbnRSb3cucGFyZW50SWQpIHtcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcbiAgICAgICAgaXNGdWxseUV4cGFuZGVkID0gY3VycmVudFJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuRXhwYW5kKSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMDtcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpID0+ICh7XG4gIHBhZ2VJbmRleDogZGVmYXVsdFBhZ2VJbmRleCxcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxufSk7XG5jb25zdCBSb3dQYWdpbmF0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIC4uLmdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSxcbiAgICAgICAgLi4uKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5wYWdpbmF0aW9uKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncGFnaW5hdGlvbicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4KCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXIgPSBvbGQgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnaW5hdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwID0gdGFibGUuaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAgOiBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpO1xuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICBwYWdlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSW5kZXgsIG1heFBhZ2VJbmRleCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlSW5kZXggPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRQYWdlSW5kZXgoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VJbmRleCA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUgPSBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDIgOiBkZWZhdWx0UGFnZUluZGV4KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDMsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VTaXplIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUyID0gX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2VTaXplKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA6IGRlZmF1bHRQYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XG4gICAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gb2xkLnBhZ2VTaXplICogb2xkLnBhZ2VJbmRleDtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vZGVwcmVjYXRlZFxuICAgIHRhYmxlLnNldFBhZ2VDb3VudCA9IHVwZGF0ZXIgPT4gdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcbiAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIChfdGFibGUkb3B0aW9ucyRwYWdlQ28gPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbyA6IC0xKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgcGFnZUNvdW50OiBuZXdQYWdlQ291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UGFnZU9wdGlvbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sIHBhZ2VDb3VudCA9PiB7XG4gICAgICBsZXQgcGFnZU9wdGlvbnMgPSBbXTtcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xuICAgICAgICBwYWdlT3B0aW9ucyA9IFsuLi5uZXcgQXJyYXkocGFnZUNvdW50KV0uZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFBhZ2VPcHRpb25zJykpO1xuICAgIHRhYmxlLmdldENhblByZXZpb3VzUGFnZSA9ICgpID0+IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbi5wYWdlSW5kZXggPiAwO1xuICAgIHRhYmxlLmdldENhbk5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYWdlSW5kZXhcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb247XG4gICAgICBjb25zdCBwYWdlQ291bnQgPSB0YWJsZS5nZXRQYWdlQ291bnQoKTtcbiAgICAgIGlmIChwYWdlQ291bnQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFnZUluZGV4IDwgcGFnZUNvdW50IC0gMTtcbiAgICB9O1xuICAgIHRhYmxlLnByZXZpb3VzUGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IG9sZCAtIDEpO1xuICAgIH07XG4gICAgdGFibGUubmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiB7XG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5maXJzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KDApO1xuICAgIH07XG4gICAgdGFibGUubGFzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KHRhYmxlLmdldFBhZ2VDb3VudCgpIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uIHx8ICF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQYWdlQ291bnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcGFnZUNvMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA6IE1hdGguY2VpbCh0YWJsZS5nZXRSb3dDb3VudCgpIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFJvd0NvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHJvd0NvdTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcm93Q291ID0gdGFibGUub3B0aW9ucy5yb3dDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHJvd0NvdSA6IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KTtcbmNvbnN0IFJvd1Bpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cucGluID0gKHBvc2l0aW9uLCBpbmNsdWRlTGVhZlJvd3MsIGluY2x1ZGVQYXJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBsZWFmUm93SWRzID0gaW5jbHVkZUxlYWZSb3dzID8gcm93LmdldExlYWZSb3dzKCkubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3QgcGFyZW50Um93SWRzID0gaW5jbHVkZVBhcmVudFJvd3MgPyByb3cuZ2V0UGFyZW50Um93cygpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3Qgcm93SWRzID0gbmV3IFNldChbLi4ucGFyZW50Um93SWRzLCByb3cuaWQsIC4uLmxlYWZSb3dJZHNdKTtcbiAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkdG9wMywgX29sZCRib3R0b20zO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wLCBfb2xkJGJvdHRvbTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiAoKF9vbGQkdG9wID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKF9vbGQkYm90dG9tID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20gOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AyLCBfb2xkJGJvdHRvbTI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogWy4uLigoX29sZCR0b3AyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AyIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldLFxuICAgICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICgoX29sZCR0b3AzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AzIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmMztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlUm93UGlubmluZyxcbiAgICAgICAgZW5hYmxlUGlubmluZ1xuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIGVuYWJsZVJvd1Bpbm5pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZVJvd1Bpbm5pbmcocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZjMgPSBlbmFibGVSb3dQaW5uaW5nICE9IG51bGwgPyBlbmFibGVSb3dQaW5uaW5nIDogZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYzIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IFtyb3cuaWRdO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHRvcC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc0JvdHRvbSA9IHJvd0lkcy5zb21lKGQgPT4gYm90dG9tID09IG51bGwgPyB2b2lkIDAgOiBib3R0b20uaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzVG9wID8gJ3RvcCcgOiBpc0JvdHRvbSA/ICdib3R0b20nIDogZmFsc2U7XG4gICAgfTtcbiAgICByb3cuZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJF9nZXRQaW5uZWRSb3dzLCBfdmlzaWJsZVBpbm5lZFJvd0lkcyQ7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xuICAgICAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIC0xO1xuICAgICAgY29uc3QgdmlzaWJsZVBpbm5lZFJvd0lkcyA9IChfdGFibGUkX2dldFBpbm5lZFJvd3MgPSB0YWJsZS5fZ2V0UGlubmVkUm93cyhwb3NpdGlvbikpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkX2dldFBpbm5lZFJvd3MubWFwKF9yZWY0ID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChfdmlzaWJsZVBpbm5lZFJvd0lkcyQgPSB2aXNpYmxlUGlubmVkUm93SWRzID09IG51bGwgPyB2b2lkIDAgOiB2aXNpYmxlUGlubmVkUm93SWRzLmluZGV4T2Yocm93LmlkKSkgIT0gbnVsbCA/IF92aXNpYmxlUGlubmVkUm93SWRzJCA6IC0xO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Um93UGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Um93UGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5yb3dQaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkdG9wID0gcGlubmluZ1N0YXRlLnRvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkdG9wLmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJGJvdHRvbSA9IHBpbm5pbmdTdGF0ZS5ib3R0b20pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGJvdHRvbS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0UGlubmVkUm93cyA9IG1lbW8ocG9zaXRpb24gPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nW3Bvc2l0aW9uXSwgcG9zaXRpb25dLCAodmlzaWJsZVJvd3MsIHBpbm5lZFJvd0lkcywgcG9zaXRpb24pID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRrZWVwUGk7XG4gICAgICBjb25zdCByb3dzID0gKChfdGFibGUkb3B0aW9ucyRrZWVwUGkgPSB0YWJsZS5vcHRpb25zLmtlZXBQaW5uZWRSb3dzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMka2VlcFBpIDogdHJ1ZSkgP1xuICAgICAgLy9nZXQgYWxsIHJvd3MgdGhhdCBhcmUgcGlubmVkIGV2ZW4gaWYgdGhleSB3b3VsZCBub3QgYmUgb3RoZXJ3aXNlIHZpc2libGVcbiAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsO1xuICAgICAgfSkgOlxuICAgICAgLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkpO1xuICAgICAgcmV0dXJuIHJvd3MuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICB9KSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdfZ2V0UGlubmVkUm93cycpKTtcbiAgICB0YWJsZS5nZXRUb3BSb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ3RvcCcpO1xuICAgIHRhYmxlLmdldEJvdHRvbVJvd3MgPSAoKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cygnYm90dG9tJyk7XG4gICAgdGFibGUuZ2V0Q2VudGVyUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLnRvcCwgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sIChhbGxSb3dzLCB0b3AsIGJvdHRvbSkgPT4ge1xuICAgICAgY29uc3QgdG9wQW5kQm90dG9tID0gbmV3IFNldChbLi4uKHRvcCAhPSBudWxsID8gdG9wIDogW10pLCAuLi4oYm90dG9tICE9IG51bGwgPyBib3R0b20gOiBbXSldKTtcbiAgICAgIHJldHVybiBhbGxSb3dzLmZpbHRlcihkID0+ICF0b3BBbmRCb3R0b20uaGFzKGQuaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldENlbnRlclJvd3MnKSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd1NlbGVjdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dTZWxlY3Rpb24nLCB0YWJsZSksXG4gICAgICBlbmFibGVSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZVN1YlJvd1NlbGVjdGlvbjogdHJ1ZVxuICAgICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgLy8gaXNBZGRpdGl2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLm1ldGFLZXksXG4gICAgICAvLyBpc0luY2x1c2l2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLnNoaWZ0S2V5LFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Um93U2VsZWN0aW9uID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Um93U2VsZWN0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93U2VsZWN0aW9uKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IHRhYmxlLmluaXRpYWxTdGF0ZS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKS5mbGF0Um93cztcblxuICAgICAgICAvLyBXZSBkb24ndCB1c2UgYG11dGF0ZVJvd0lzU2VsZWN0ZWRgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgIC8vIEFsbCBvZiB0aGUgcm93cyBhcmUgZmxhdCBhbHJlYWR5LCBzbyBpdCB3b3VsZG4ndCBiZSB3b3J0aCBpdFxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgaWYgKCFyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U2VsZWN0aW9uW3Jvdy5pZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBkZWxldGUgcm93U2VsZWN0aW9uW3Jvdy5pZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKTtcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4ub2xkXG4gICAgICB9O1xuICAgICAgdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChyb3dTZWxlY3Rpb24sIHJvdy5pZCwgcmVzb2x2ZWRWYWx1ZSwgdHJ1ZSwgdGFibGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkUm93U2VsZWN0aW9uUmFuZ2U6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHtcbiAgICAvLyAgICAgcm93cyxcbiAgICAvLyAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgIG9wdGlvbnM6IHsgc2VsZWN0R3JvdXBpbmdSb3dzLCBzZWxlY3RTdWJSb3dzIH0sXG4gICAgLy8gICB9ID0gdGFibGVcblxuICAgIC8vICAgY29uc3QgZmluZFNlbGVjdGVkUm93ID0gKHJvd3M6IFJvd1tdKSA9PiB7XG4gICAgLy8gICAgIGxldCBmb3VuZFxuICAgIC8vICAgICByb3dzLmZpbmQoZCA9PiB7XG4gICAgLy8gICAgICAgaWYgKGQuZ2V0SXNTZWxlY3RlZCgpKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IGRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIGNvbnN0IHN1YkZvdW5kID0gZmluZFNlbGVjdGVkUm93KGQuc3ViUm93cyB8fCBbXSlcbiAgICAvLyAgICAgICBpZiAoc3ViRm91bmQpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gc3ViRm91bmRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9KVxuICAgIC8vICAgICByZXR1cm4gZm91bmRcbiAgICAvLyAgIH1cblxuICAgIC8vICAgY29uc3QgZmlyc3RSb3cgPSBmaW5kU2VsZWN0ZWRSb3cocm93cykgfHwgcm93c1swXVxuICAgIC8vICAgY29uc3QgbGFzdFJvdyA9IHJvd3NCeUlkW3Jvd0lkXVxuXG4gICAgLy8gICBsZXQgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHt9XG5cbiAgICAvLyAgIGNvbnN0IGFkZFJvdyA9IChyb3c6IFJvdykgPT4ge1xuICAgIC8vICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHRydWUsIHtcbiAgICAvLyAgICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgICBzZWxlY3RHcm91cGluZ1Jvd3M6IHNlbGVjdEdyb3VwaW5nUm93cyEsXG4gICAgLy8gICAgICAgc2VsZWN0U3ViUm93czogc2VsZWN0U3ViUm93cyEsXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHRhYmxlLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIC8vICAgICBjb25zdCBpc0ZpcnN0Um93ID0gcm93LmlkID09PSBmaXJzdFJvdy5pZFxuICAgIC8vICAgICBjb25zdCBpc0xhc3RSb3cgPSByb3cuaWQgPT09IGxhc3RSb3cuaWRcblxuICAgIC8vICAgICBpZiAoaXNGaXJzdFJvdyB8fCBpc0xhc3RSb3cpIHtcbiAgICAvLyAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSB0cnVlXG4gICAgLy8gICAgICAgfSBlbHNlIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG5cbiAgICAvLyAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9KVxuXG4gICAgLy8gICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dJZHMpXG4gICAgLy8gfSxcbiAgICB0YWJsZS5nZXRQcmVTZWxlY3RlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFNlbGVjdGVkUm93TW9kZWwnKSk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCcpKTtcbiAgICB0YWJsZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwnKSk7XG5cbiAgICAvLy9cblxuICAgIC8vIGdldEdyb3VwaW5nUm93Q2FuU2VsZWN0OiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQpXG5cbiAgICAvLyAgIGlmICghcm93KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXG4gICAgLy8gfSxcblxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihwcmVHcm91cGVkRmxhdFJvd3MubGVuZ3RoICYmIE9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKTtcbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBpZiAocHJlR3JvdXBlZEZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSAmJiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICEhcGFnaW5hdGlvbkZsYXRSb3dzLmxlbmd0aDtcbiAgICAgIGlmIChpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgcGFnaW5hdGlvbkZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRyb3dTZTtcbiAgICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWQgPSBPYmplY3Qua2V5cygoX3RhYmxlJGdldFN0YXRlJHJvd1NlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkcm93U2UgOiB7fSkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRvdGFsU2VsZWN0ZWQgPiAwICYmIHRvdGFsU2VsZWN0ZWQgPCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3MubGVuZ3RoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgcmV0dXJuIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpID8gZmFsc2UgOiBwYWdpbmF0aW9uRmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpLnNvbWUoZCA9PiBkLmdldElzU2VsZWN0ZWQoKSB8fCBkLmdldElzU29tZVNlbGVjdGVkKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkID0gKHZhbHVlLCBvcHRzKSA9PiB7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gcm93LmdldElzU2VsZWN0ZWQoKTtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YXIgX29wdHMkc2VsZWN0Q2hpbGRyZW47XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIWlzU2VsZWN0ZWQ7XG4gICAgICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgaXNTZWxlY3RlZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCAoX29wdHMkc2VsZWN0Q2hpbGRyZW4gPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNlbGVjdENoaWxkcmVuKSAhPSBudWxsID8gX29wdHMkc2VsZWN0Q2hpbGRyZW4gOiB0cnVlLCB0YWJsZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFJvd0lkcztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdzb21lJztcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ2FsbCc7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5NdWx0aVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU2VsZWN0ID0gcm93LmdldENhblNlbGVjdCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgaWYgKCFjYW5TZWxlY3QpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZVNlbGVjdGVkKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgbXV0YXRlUm93SXNTZWxlY3RlZCA9IChzZWxlY3RlZFJvd0lkcywgaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSA9PiB7XG4gIHZhciBfcm93JHN1YlJvd3M7XG4gIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhpZCwgdHJ1ZSk7XG5cbiAgLy8gY29uc3QgaXNHcm91cGVkID0gcm93LmdldElzR3JvdXBlZCgpXG5cbiAgLy8gaWYgKCAvLyBUT0RPOiBlbmZvcmNlIGdyb3VwaW5nIHJvdyBzZWxlY3Rpb24gcnVsZXNcbiAgLy8gICAhaXNHcm91cGVkIHx8XG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxuICAvLyApIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xuICAgICAgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1trZXldKTtcbiAgICB9XG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgc2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHNlbGVjdGVkUm93SWRzW2lkXTtcbiAgfVxuICAvLyB9XG5cbiAgaWYgKGluY2x1ZGVDaGlsZHJlbiAmJiAoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cygpKSB7XG4gICAgcm93LnN1YlJvd3MuZm9yRWFjaChyb3cgPT4gbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkpO1xuICB9XG59O1xuZnVuY3Rpb24gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCkge1xuICBjb25zdCByb3dTZWxlY3Rpb24gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbjtcbiAgY29uc3QgbmV3U2VsZWN0ZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdTZWxlY3RlZFJvd3NCeUlkID0ge307XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VSb3dzID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIG5ld1NlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCkge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgLi4ucm93LFxuICAgICAgICAgIHN1YlJvd3M6IHJlY3Vyc2VSb3dzKHJvdy5zdWJSb3dzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH1cbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZVJvd3Mocm93TW9kZWwucm93cyksXG4gICAgZmxhdFJvd3M6IG5ld1NlbGVjdGVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld1NlbGVjdGVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24pIHtcbiAgdmFyIF9zZWxlY3Rpb24kcm93JGlkO1xuICByZXR1cm4gKF9zZWxlY3Rpb24kcm93JGlkID0gc2VsZWN0aW9uW3Jvdy5pZF0pICE9IG51bGwgPyBfc2VsZWN0aW9uJHJvdyRpZCA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTdWJSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbiwgdGFibGUpIHtcbiAgdmFyIF9yb3ckc3ViUm93czM7XG4gIGlmICghKChfcm93JHN1YlJvd3MzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMy5sZW5ndGgpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICByb3cuc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ViUm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBpZiAoaXNSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbikpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayByb3cgc2VsZWN0aW9uIG9mIG5lc3RlZCBzdWJyb3dzXG4gICAgaWYgKHN1YlJvdy5zdWJSb3dzICYmIHN1YlJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9IGlzU3ViUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdhbGwnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdzb21lJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbENoaWxkcmVuU2VsZWN0ZWQgPyAnYWxsJyA6IHNvbWVTZWxlY3RlZCA/ICdzb21lJyA6IGZhbHNlO1xufVxuXG5jb25zdCByZVNwbGl0QWxwaGFOdW1lcmljID0gLyhbMC05XSspL2dtO1xuY29uc3QgYWxwaGFudW1lcmljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuY29uc3QgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHQgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0Q2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5jb25zdCBkYXRldGltZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICBjb25zdCBhID0gcm93QS5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlKGNvbHVtbklkKTtcblxuICAvLyBDYW4gaGFuZGxlIG51bGxpc2ggdmFsdWVzXG4gIC8vIFVzZSA+IGFuZCA8IGJlY2F1c2UgPT0gKGFuZCA9PT0pIGRvZXNuJ3Qgd29yayB3aXRoXG4gIC8vIERhdGUgb2JqZWN0cyAod291bGQgcmVxdWlyZSBjYWxsaW5nIGdldFRpbWUoKSkuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5jb25zdCBiYXNpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpLCByb3dCLmdldFZhbHVlKGNvbHVtbklkKSk7XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vLyBNaXhlZCBzb3J0aW5nIGlzIHNsb3csIGJ1dCB2ZXJ5IGluY2x1c2l2ZSBvZiBtYW55IGVkZ2UgY2FzZXMuXG4vLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4vLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuZnVuY3Rpb24gY29tcGFyZUFscGhhbnVtZXJpYyhhU3RyLCBiU3RyKSB7XG4gIC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuICBjb25zdCBhID0gYVN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IGIgPSBiU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyBXaGlsZVxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICBjb25zdCBhYSA9IGEuc2hpZnQoKTtcbiAgICBjb25zdCBiYiA9IGIuc2hpZnQoKTtcbiAgICBjb25zdCBhbiA9IHBhcnNlSW50KGFhLCAxMCk7XG4gICAgY29uc3QgYm4gPSBwYXJzZUludChiYiwgMTApO1xuICAgIGNvbnN0IGNvbWJvID0gW2FuLCBibl0uc29ydCgpO1xuXG4gICAgLy8gQm90aCBhcmUgc3RyaW5nXG4gICAgaWYgKGlzTmFOKGNvbWJvWzBdKSkge1xuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgIHJldHVybiBpc05hTihhbikgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLy8gQm90aCBhcmUgbnVtYmVyc1xuICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGJuID4gYW4pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5cbi8vIEV4cG9ydHNcblxuY29uc3Qgc29ydGluZ0ZucyA9IHtcbiAgYWxwaGFudW1lcmljLFxuICBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlLFxuICB0ZXh0LFxuICB0ZXh0Q2FzZVNlbnNpdGl2ZSxcbiAgZGF0ZXRpbWUsXG4gIGJhc2ljXG59O1xuXG4vL1xuXG5jb25zdCBSb3dTb3J0aW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZ0ZuOiAnYXV0bycsXG4gICAgICBzb3J0VW5kZWZpbmVkOiAxXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Tb3J0aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdzb3J0aW5nJywgdGFibGUpLFxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogZSA9PiB7XG4gICAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMCk7XG4gICAgICBsZXQgaXNTdHJpbmcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGZpcnN0Um93cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdyA9PSBudWxsID8gdm9pZCAwIDogcm93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5kYXRldGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodmFsdWUuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYWxwaGFudW1lcmljO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nRm5zLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpYztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydERpciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnYXNjJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHNvcnRpbiwgX3RhYmxlJG9wdGlvbnMkc29ydGluMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4pID8gY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4oKSA6IChfdGFibGUkb3B0aW9ucyRzb3J0aW4gPSAoX3RhYmxlJG9wdGlvbnMkc29ydGluMiA9IHRhYmxlLm9wdGlvbnMuc29ydGluZ0ZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJHNvcnRpbjJbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkc29ydGluIDogc29ydGluZ0Zuc1tjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl07XG4gICAgfTtcbiAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9IChkZXNjLCBtdWx0aSkgPT4ge1xuICAgICAgLy8gaWYgKGNvbHVtbi5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgLy8gICBjb2x1bW4uY29sdW1ucy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAvLyAgICAgaWYgKGMuaWQpIHtcbiAgICAgIC8vICAgICAgIHRhYmxlLnRvZ2dsZUNvbHVtblNvcnRpbmcoYy5pZCwgdW5kZWZpbmVkLCBtdWx0aSB8fCAhIWkpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9KVxuICAgICAgLy8gICByZXR1cm5cbiAgICAgIC8vIH1cblxuICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdXRzaWRlIG9mIHRhYmxlLnNldFNvcnRpbmcgdG8gYmUgaW4gc3luYyB3aXRoIHJlcmVuZGVyXG4gICAgICBjb25zdCBuZXh0U29ydGluZ09yZGVyID0gY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIoKTtcbiAgICAgIGNvbnN0IGhhc01hbnVhbFZhbHVlID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIHNvcnRpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU29ydGluZyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgbGV0IG5ld1NvcnRpbmcgPSBbXTtcblxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG4gICAgICAgIGxldCBzb3J0QWN0aW9uO1xuICAgICAgICBsZXQgbmV4dERlc2MgPSBoYXNNYW51YWxWYWx1ZSA/IGRlc2MgOiBuZXh0U29ydGluZ09yZGVyID09PSAnZGVzYyc7XG5cbiAgICAgICAgLy8gTXVsdGktbW9kZVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgJiYgbXVsdGkpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBleGlzdGluZ0luZGV4ICE9PSBvbGQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRpbmdcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XG4gICAgICAgICAgaWYgKCFoYXNNYW51YWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSXMgb3VyIGludGVudGlvbiB0byByZW1vdmU/XG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcbiAgICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TXVsO1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbLi4ub2xkLCB7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZSgwLCBuZXdTb3J0aW5nLmxlbmd0aCAtICgoX3RhYmxlJG9wdGlvbnMkbWF4TXVsID0gdGFibGUub3B0aW9ucy5tYXhNdWx0aVNvcnRDb2xDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heE11bCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBUaGlzIGZsaXBzIChvciBzZXRzKSB0aGVcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gW3tcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTb3J0aW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJHNvcjtcbiAgICAgIGNvbnN0IHNvcnREZXNjRmlyc3QgPSAoX3JlZiA9IChfY29sdW1uJGNvbHVtbkRlZiRzb3IgPSBjb2x1bW4uY29sdW1uRGVmLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRzb3IgOiB0YWJsZS5vcHRpb25zLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfcmVmIDogY29sdW1uLmdldEF1dG9Tb3J0RGlyKCkgPT09ICdkZXNjJztcbiAgICAgIHJldHVybiBzb3J0RGVzY0ZpcnN0ID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlciA9IG11bHRpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBjb25zdCBmaXJzdFNvcnREaXJlY3Rpb24gPSBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyKCk7XG4gICAgICBjb25zdCBpc1NvcnRlZCA9IGNvbHVtbi5nZXRJc1NvcnRlZCgpO1xuICAgICAgaWYgKCFpc1NvcnRlZCkge1xuICAgICAgICByZXR1cm4gZmlyc3RTb3J0RGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9PSBmaXJzdFNvcnREaXJlY3Rpb24gJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmdSZW1vdmFsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKFxuICAgICAgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgIG11bHRpID8gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUmVtb3ZlKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUgOiB0cnVlKSAvLyBJZiBtdWx0aSwgZG9uJ3QgYWxsb3cgaWYgZW5hYmxlTXVsdGlSZW1vdmUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NvcnRlZCA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjIsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTI7XG4gICAgICByZXR1cm4gKF9yZWYyID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9yZWYyIDogISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1NvcnRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGk7XG4gICAgICBjb25zdCBjb2x1bW5Tb3J0ID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgIHJldHVybiAhY29sdW1uU29ydCA/IGZhbHNlIDogY29sdW1uU29ydC5kZXNjID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIsIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMyA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICAvL2NsZWFyIHNvcnRpbmcgZm9yIGp1c3QgMSBjb2x1bW5cbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggPyBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSA6IFtdKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNvcnQgPSBjb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNhblNvcnQpIHJldHVybjtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVNvcnRpbmcodW5kZWZpbmVkLCBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudChlKSA6IGZhbHNlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRTb3J0aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5zb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRzIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFNvcnRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxTb3J0aW5nIHx8ICF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgYnVpbHRJbkZlYXR1cmVzID0gW0hlYWRlcnMsIENvbHVtblZpc2liaWxpdHksIENvbHVtbk9yZGVyaW5nLCBDb2x1bW5QaW5uaW5nLCBDb2x1bW5GYWNldGluZywgQ29sdW1uRmlsdGVyaW5nLCBHbG9iYWxGaWx0ZXJpbmcsXG4vL2RlcGVuZHMgb24gQ29sdW1uRmlsdGVyaW5nIGFuZCBDb2x1bW5GYWNldGluZ1xuUm93U29ydGluZywgQ29sdW1uR3JvdXBpbmcsXG4vL2RlcGVuZHMgb24gUm93U29ydGluZ1xuUm93RXhwYW5kaW5nLCBSb3dQYWdpbmF0aW9uLCBSb3dQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIENvbHVtblNpemluZ107XG5cbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJF9mZWF0dXJlcywgX29wdGlvbnMkaW5pdGlhbFN0YXRlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAob3B0aW9ucy5kZWJ1Z0FsbCB8fCBvcHRpb25zLmRlYnVnVGFibGUpKSB7XG4gICAgY29uc29sZS5pbmZvKCdDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLicpO1xuICB9XG4gIGNvbnN0IF9mZWF0dXJlcyA9IFsuLi5idWlsdEluRmVhdHVyZXMsIC4uLigoX29wdGlvbnMkX2ZlYXR1cmVzID0gb3B0aW9ucy5fZmVhdHVyZXMpICE9IG51bGwgPyBfb3B0aW9ucyRfZmVhdHVyZXMgOiBbXSldO1xuICBsZXQgdGFibGUgPSB7XG4gICAgX2ZlYXR1cmVzXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zKHRhYmxlKSk7XG4gIH0sIHt9KTtcbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgaWYgKHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZSA9IHt9O1xuICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmNvcmVJbml0aWFsU3RhdGUsXG4gICAgLi4uKChfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZSkgIT0gbnVsbCA/IF9vcHRpb25zJGluaXRpYWxTdGF0ZSA6IHt9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICB2YXIgX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0O1xuICAgIGluaXRpYWxTdGF0ZSA9IChfZmVhdHVyZSRnZXRJbml0aWFsU3QgPSBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSkgIT0gbnVsbCA/IF9mZWF0dXJlJGdldEluaXRpYWxTdCA6IGluaXRpYWxTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHF1ZXVlZCA9IFtdO1xuICBsZXQgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICBjb25zdCBjb3JlSW5zdGFuY2UgPSB7XG4gICAgX2ZlYXR1cmVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIF9xdWV1ZTogY2IgPT4ge1xuICAgICAgcXVldWVkLnB1c2goY2IpO1xuICAgICAgaWYgKCFxdWV1ZWRUaW1lb3V0KSB7XG4gICAgICAgIHF1ZXVlZFRpbWVvdXQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGEgbWljcm90YXNrIHRvIHJ1biB0aGUgcXVldWVkIGNhbGxiYWNrcyBhZnRlclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAocXVldWVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWVkLnNoaWZ0KCkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldFN0YXRlKHRhYmxlLmluaXRpYWxTdGF0ZSk7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpO1xuICAgICAgdGFibGUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICB9LFxuICAgIGdldFN0YXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5zdGF0ZTtcbiAgICB9LFxuICAgIHNldFN0YXRlOiB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcbiAgICB9LFxuICAgIF9nZXRSb3dJZDogKHJvdywgaW5kZXgsIHBhcmVudCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dJZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogYCR7cGFyZW50ID8gW3BhcmVudC5pZCwgaW5kZXhdLmpvaW4oJy4nKSA6IGluZGV4fWA7XG4gICAgfSxcbiAgICBnZXRDb3JlUm93TW9kZWw6ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldENvcmVSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vIFRoZSBmaW5hbCBjYWxscyBzdGFydCBhdCB0aGUgYm90dG9tIG9mIHRoZSBtb2RlbCxcbiAgICAvLyBleHBhbmRlZCByb3dzLCB3aGljaCB0aGVuIHdvcmsgdGhlaXIgd2F5IHVwXG5cbiAgICBnZXRSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgLy9pbiBuZXh0IHZlcnNpb24sIHdlIHNob3VsZCBqdXN0IHBhc3MgaW4gdGhlIHJvdyBtb2RlbCBhcyB0aGUgb3B0aW9uYWwgMm5kIGFyZ1xuICAgIGdldFJvdzogKGlkLCBzZWFyY2hBbGwpID0+IHtcbiAgICAgIGxldCByb3cgPSAoc2VhcmNoQWxsID8gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkgOiB0YWJsZS5nZXRSb3dNb2RlbCgpKS5yb3dzQnlJZFtpZF07XG4gICAgICBpZiAoIXJvdykge1xuICAgICAgICByb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5yb3dzQnlJZFtpZF07XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93IGNvdWxkIG5vdCBmaW5kIHJvdyB3aXRoIElEOiAke2lkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCBkZWZhdWx0Q29sdW1uID0+IHtcbiAgICAgIHZhciBfZGVmYXVsdENvbHVtbjtcbiAgICAgIGRlZmF1bHRDb2x1bW4gPSAoX2RlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uKSAhPSBudWxsID8gX2RlZmF1bHRDb2x1bW4gOiB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjogcHJvcHMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0gcHJvcHMuaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWY7XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmb290ZXI6IHByb3BzID0+IHByb3BzLmhlYWRlci5jb2x1bW4uaWQsXG4gICAgICAgIGNlbGw6IHByb3BzID0+IHtcbiAgICAgICAgICB2YXIgX3Byb3BzJHJlbmRlclZhbHVlJHRvLCBfcHJvcHMkcmVuZGVyVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIChfcHJvcHMkcmVuZGVyVmFsdWUkdG8gPSAoX3Byb3BzJHJlbmRlclZhbHVlID0gcHJvcHMucmVuZGVyVmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3Byb3BzJHJlbmRlclZhbHVlJHRvIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLi4udGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZigpKTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICAuLi5kZWZhdWx0Q29sdW1uXG4gICAgICB9O1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnX2dldERlZmF1bHRDb2x1bW5EZWYnKSksXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IHRhYmxlLm9wdGlvbnMuY29sdW1ucyxcbiAgICBnZXRBbGxDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0Q29sdW1uRGVmcygpXSwgY29sdW1uRGVmcyA9PiB7XG4gICAgICBjb25zdCByZWN1cnNlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5EZWZzLCBwYXJlbnQsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5EZWZzLm1hcChjb2x1bW5EZWYgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KTtcbiAgICAgICAgICBjb25zdCBncm91cGluZ0NvbHVtbkRlZiA9IGNvbHVtbkRlZjtcbiAgICAgICAgICBjb2x1bW4uY29sdW1ucyA9IGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMgPyByZWN1cnNlQ29sdW1ucyhncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSkgOiBbXTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVjdXJzZUNvbHVtbnMoY29sdW1uRGVmcyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxDb2x1bW5zJykpLFxuICAgIGdldEFsbEZsYXRDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCldLCBhbGxDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRGbGF0Q29sdW1ucygpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxGbGF0Q29sdW1ucycpKSxcbiAgICBfZ2V0QWxsRmxhdENvbHVtbnNCeUlkOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpXSwgZmxhdENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IHtcbiAgICAgICAgYWNjW2NvbHVtbi5pZF0gPSBjb2x1bW47XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxGbGF0Q29sdW1uc0J5SWQnKSksXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XG4gICAgICBsZXQgbGVhZkNvbHVtbnMgPSBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsTGVhZkNvbHVtbnMnKSksXG4gICAgZ2V0Q29sdW1uOiBjb2x1bW5JZCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5fZ2V0QWxsRmxhdENvbHVtbnNCeUlkKClbY29sdW1uSWRdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbHVtbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbVGFibGVdIENvbHVtbiB3aXRoIGlkICcke2NvbHVtbklkfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih0YWJsZSwgY29yZUluc3RhbmNlKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2luZGV4XTtcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUodGFibGUpO1xuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29yZVJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kYXRhXSwgZGF0YSA9PiB7XG4gICAgY29uc3Qgcm93TW9kZWwgPSB7XG4gICAgICByb3dzOiBbXSxcbiAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgIHJvd3NCeUlkOiB7fVxuICAgIH07XG4gICAgY29uc3QgYWNjZXNzUm93cyA9IGZ1bmN0aW9uIChvcmlnaW5hbFJvd3MsIGRlcHRoLCBwYXJlbnRSb3cpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gZXhwZW5zaXZlIGNoZWNrIGF0IHNjYWxlLCBzbyB3ZSBzaG91bGQgbW92ZSBpdCBzb21ld2hlcmUgZWxzZSwgYnV0IHdoZXJlP1xuICAgICAgICAvLyBpZiAoIWlkKSB7XG4gICAgICAgIC8vICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93SWQgZXhwZWN0ZWQgYW4gSUQsIGJ1dCBnb3QgJHtpZH1gKVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIE1ha2UgdGhlIHJvd1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIHRhYmxlLl9nZXRSb3dJZChvcmlnaW5hbFJvd3NbaV0sIGksIHBhcmVudFJvdyksIG9yaWdpbmFsUm93c1tpXSwgaSwgZGVwdGgsIHVuZGVmaW5lZCwgcGFyZW50Um93ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnRSb3cuaWQpO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGluIGEgZmxhdCBhcnJheVxuICAgICAgICByb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXG4gICAgICAgIHJvd01vZGVsLnJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgIC8vIFB1c2ggdGFibGUgcm93IGludG8gcGFyZW50XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgb3JpZ2luYWwgc3Vicm93c1xuICAgICAgICBpZiAodGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKSB7XG4gICAgICAgICAgdmFyIF9yb3ckb3JpZ2luYWxTdWJSb3dzO1xuICAgICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MgPSB0YWJsZS5vcHRpb25zLmdldFN1YlJvd3Mob3JpZ2luYWxSb3dzW2ldLCBpKTtcblxuICAgICAgICAgIC8vIFRoZW4gcmVjdXJzaXZlbHkgYWNjZXNzIHRoZW1cbiAgICAgICAgICBpZiAoKF9yb3ckb3JpZ2luYWxTdWJSb3dzID0gcm93Lm9yaWdpbmFsU3ViUm93cykgIT0gbnVsbCAmJiBfcm93JG9yaWdpbmFsU3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gYWNjZXNzUm93cyhyb3cub3JpZ2luYWxTdWJSb3dzLCBkZXB0aCArIDEsIHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIHJvd01vZGVsLnJvd3MgPSBhY2Nlc3NSb3dzKGRhdGEpO1xuICAgIHJldHVybiByb3dNb2RlbDtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0Um93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c10sIChleHBhbmRlZCwgcm93TW9kZWwsIHBhZ2luYXRlRXhwYW5kZWRSb3dzKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCBleHBhbmRlZCAhPT0gdHJ1ZSAmJiAhT2JqZWN0LmtleXMoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDoge30pLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBpZiAoIXBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAvLyBPbmx5IGV4cGFuZCByb3dzIGF0IHRoaXMgcG9pbnQgaWYgdGhleSBhcmUgYmVpbmcgcGFnaW5hdGVkXG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRSb3dzKHJvd01vZGVsKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcpKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93TW9kZWwpIHtcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XG4gIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0SXNFeHBhbmRlZCgpKSB7XG4gICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgfVxuICB9O1xuICByb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICB2YXIgX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0O1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSAoX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0ID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0LmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSBbZmlyc3RWYWx1ZSwgZmlyc3RWYWx1ZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmICh2YWx1ZSA8IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzBdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBmYWNldGVkTWluTWF4VmFsdWVzWzFdKSB7XG4gICAgICAgICAgZmFjZXRlZE1pbk1heFZhbHVlc1sxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkTWluTWF4VmFsdWVzO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkTWluTWF4VmFsdWVzJykpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSb3dzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKSB7XG4gIGlmICh0YWJsZS5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cykge1xuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWE7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYSA6IDEwMDtcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgIG5ld1Jvdy5jb2x1bW5GaWx0ZXJzID0gcm93LmNvbHVtbkZpbHRlcnM7XG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KTtcbiAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXIsIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChwcmVSb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gWy4uLmNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCkuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uSWQpLCBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWRdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmFjZXRlZFJvd01vZGVsJykpO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkVW5pcXVlVmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICBsZXQgZmFjZXRlZFVuaXF1ZVZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKGZhY2V0ZWRVbmlxdWVWYWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQ7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsICgoX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkID0gZmFjZXRlZFVuaXF1ZVZhbHVlcy5nZXQodmFsdWUpKSAhPSBudWxsID8gX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIDogMCkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRVbmlxdWVWYWx1ZXM7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgYGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJHtjb2x1bW5JZH1gKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZpbHRlcmVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXJdLCAocm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZEdsb2JhbEZpbHRlcnMgPSBbXTtcbiAgICAoY29sdW1uRmlsdGVycyAhPSBudWxsID8gY29sdW1uRmlsdGVycyA6IFtdKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgdmFyIF9maWx0ZXJGbiRyZXNvbHZlRmlsdDtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihkLmlkKTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICBpZiAoIWZpbHRlckZuKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBhIHZhbGlkICdjb2x1bW4uZmlsdGVyRm4nIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6ICR7Y29sdW1uLmlkfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICBmaWx0ZXJGbixcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA9IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGQudmFsdWUpKSAhPSBudWxsID8gX2ZpbHRlckZuJHJlc29sdmVGaWx0IDogZC52YWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IGNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCk7XG4gICAgY29uc3QgZ2xvYmFsRmlsdGVyRm4gPSB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbigpO1xuICAgIGNvbnN0IGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldENhbkdsb2JhbEZpbHRlcigpKTtcbiAgICBpZiAoZ2xvYmFsRmlsdGVyICYmIGdsb2JhbEZpbHRlckZuICYmIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBmaWx0ZXJhYmxlSWRzLnB1c2goJ19fZ2xvYmFsX18nKTtcbiAgICAgIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX2dsb2JhbEZpbHRlckZuJHJlc29sO1xuICAgICAgICByZXNvbHZlZEdsb2JhbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICBmaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4sXG4gICAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA9IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGdsb2JhbEZpbHRlcikpICE9IG51bGwgPyBfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgOiBnbG9iYWxGaWx0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRDb2x1bW5GaWx0ZXI7XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXI7XG5cbiAgICAvLyBGbGFnIHRoZSBwcmVmaWx0ZXJlZCByb3cgbW9kZWwgd2l0aCBlYWNoIGZpbHRlciBzdGF0ZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHJvd01vZGVsLmZsYXRSb3dzW2pdO1xuICAgICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgIGlmIChyZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudENvbHVtbkZpbHRlciA9IHJlc29sdmVkQ29sdW1uRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuaWQ7XG5cbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBjb2x1bW4gZmlsdGVyIHN0YXRlXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNbaWRdID0gY3VycmVudENvbHVtbkZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEdsb2JhbEZpbHRlciA9IHJlc29sdmVkR2xvYmFsRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRHbG9iYWxGaWx0ZXIuaWQ7XG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICBpZiAoY3VycmVudEdsb2JhbEZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50R2xvYmFsRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSB0cnVlKSB7XG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIEZpbHRlciBmaW5hbCByb3dzIHVzaW5nIGFsbCBvZiB0aGUgYWN0aXZlIGZpbHRlcnNcbiAgICByZXR1cm4gZmlsdGVyUm93cyhyb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFJvd01vZGVsJywgKCkgPT4gdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpXSwgKGdyb3VwaW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciB0aGUgZ3JvdXBpbmcgbGlzdCBkb3duIHRvIGNvbHVtbnMgdGhhdCBleGlzdFxuICAgIGNvbnN0IGV4aXN0aW5nR3JvdXBpbmcgPSBncm91cGluZy5maWx0ZXIoY29sdW1uSWQgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSk7XG4gICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgY29uc3QgZ3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG4gICAgY29uc3QgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgLy8gR3JvdXBpbmcgZGVwdGggaGFzIGJlZW4gYmVlbiBtZXRcbiAgICAgIC8vIFN0b3AgZ3JvdXBpbmcgYW5kIHNpbXBseSByZXdyaXRlIHRoZCBkZXB0aCBhbmQgcm93IHJlbGF0aW9uc2hpcHNcbiAgICAgIGlmIChkZXB0aCA+PSBleGlzdGluZ0dyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByb3cuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93LnN1YlJvd3MsIGRlcHRoICsgMSwgcm93LmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW5JZCA9IGV4aXN0aW5nR3JvdXBpbmdbZGVwdGhdO1xuXG4gICAgICAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuICAgICAgY29uc3Qgcm93R3JvdXBzTWFwID0gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCk7XG5cbiAgICAgIC8vIFBlZm9ybSBhZ2dyZWdhdGlvbnMgZm9yIGVhY2ggZ3JvdXBcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRHcm91cGVkUm93cyA9IEFycmF5LmZyb20ocm93R3JvdXBzTWFwLmVudHJpZXMoKSkubWFwKChfcmVmLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgW2dyb3VwaW5nVmFsdWUsIGdyb3VwZWRSb3dzXSA9IF9yZWY7XG4gICAgICAgIGxldCBpZCA9IGAke2NvbHVtbklkfToke2dyb3VwaW5nVmFsdWV9YDtcbiAgICAgICAgaWQgPSBwYXJlbnRJZCA/IGAke3BhcmVudElkfT4ke2lkfWAgOiBpZDtcblxuICAgICAgICAvLyBGaXJzdCwgUmVjdXJzZSB0byBncm91cCBzdWIgcm93cyBiZWZvcmUgYWdncmVnYXRpb25cbiAgICAgICAgY29uc3Qgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZCk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgbGVhZiByb3dzIG9mIHRoZSByb3dzIGluIHRoaXMgZ3JvdXBcbiAgICAgICAgY29uc3QgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgcm93ID0+IHJvdy5zdWJSb3dzKSA6IGdyb3VwZWRSb3dzO1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIGlkLCBsZWFmUm93c1swXS5vcmlnaW5hbCwgaW5kZXgsIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudElkKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcbiAgICAgICAgICBncm91cGluZ0NvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgICBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgIHN1YlJvd3MsXG4gICAgICAgICAgbGVhZlJvd3MsXG4gICAgICAgICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cGluZ1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBpbmcuaW5jbHVkZXMoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFJvd3NbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dyb3VwZWRSb3dzJDAkZ2V0VmFsO1xuICAgICAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gKF9ncm91cGVkUm93cyQwJGdldFZhbCA9IGdyb3VwZWRSb3dzWzBdLmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9ncm91cGVkUm93cyQwJGdldFZhbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVGbiA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4oKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gYWdncmVnYXRlRm4oY29sdW1uSWQsIGxlYWZSb3dzLCBncm91cGVkUm93cyk7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZ2dyZWdhdGVkR3JvdXBlZFJvd3M7XG4gICAgfTtcbiAgICBjb25zdCBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dNb2RlbC5yb3dzLCAwKTtcbiAgICBncm91cGVkUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBncm91cGVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkXG4gICAgfTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0R3JvdXBlZFJvd01vZGVsJywgKCkgPT4ge1xuICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQoKTtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9KTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCkge1xuICBjb25zdCBncm91cE1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHJvd3MucmVkdWNlKChtYXAsIHJvdykgPT4ge1xuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gO1xuICAgIGNvbnN0IHByZXZpb3VzID0gbWFwLmdldChyZXNLZXkpO1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIG1hcC5zZXQocmVzS2V5LCBbcm93XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzLnB1c2gocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgZ3JvdXBNYXApO1xufVxuXG5mdW5jdGlvbiBnZXRQYWdpbmF0aW9uUm93TW9kZWwob3B0cykge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkXG4gICAgfSA9IHJvd01vZGVsO1xuICAgIGNvbnN0IHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgIGNvbnN0IHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyBwYWdlU2l6ZTtcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgIGxldCBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH07XG4gICAgfVxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJvd01vZGVsO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHNvcnRpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKHNvcnRpbmcgIT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nO1xuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHNvcnRpbmdzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldENhblNvcnQoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5JbmZvQnlJZCA9IHt9O1xuICAgIGF2YWlsYWJsZVNvcnRpbmcuZm9yRWFjaChzb3J0RW50cnkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikgcmV0dXJuO1xuICAgICAgY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXSA9IHtcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjb2x1bW4uY29sdW1uRGVmLmludmVydFNvcnRpbmcsXG4gICAgICAgIHNvcnRpbmdGbjogY29sdW1uLmdldFNvcnRpbmdGbigpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNvcnREYXRhID0gcm93cyA9PiB7XG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi5yb3dcbiAgICAgIH0pKTtcbiAgICAgIHNvcnRlZERhdGEuc29ydCgocm93QSwgcm93QikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgX3NvcnRFbnRyeSRkZXNjO1xuICAgICAgICAgIGNvbnN0IHNvcnRFbnRyeSA9IGF2YWlsYWJsZVNvcnRpbmdbaV07XG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XG4gICAgICAgICAgY29uc3QgaXNEZXNjID0gKF9zb3J0RW50cnkkZGVzYyA9IHNvcnRFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogc29ydEVudHJ5LmRlc2MpICE9IG51bGwgPyBfc29ydEVudHJ5JGRlc2MgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgc29ydEludCA9IDA7XG5cbiAgICAgICAgICAvLyBBbGwgc29ydGluZyBpbnRzIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIGlmIChjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGJWYWx1ZSA9IHJvd0IuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhVW5kZWZpbmVkIHx8IGJVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc29ydEludCA9IGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZCA/IDAgOiBhVW5kZWZpbmVkID8gY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkIDogLWNvbHVtbkluZm8uc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cbiAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZm8uaW52ZXJ0U29ydGluZykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dBLmluZGV4IC0gcm93Qi5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgICB9O1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTb3J0ZWRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5leHBvcnQgeyBDb2x1bW5GYWNldGluZywgQ29sdW1uRmlsdGVyaW5nLCBDb2x1bW5Hcm91cGluZywgQ29sdW1uT3JkZXJpbmcsIENvbHVtblBpbm5pbmcsIENvbHVtblNpemluZywgQ29sdW1uVmlzaWJpbGl0eSwgR2xvYmFsRmlsdGVyaW5nLCBIZWFkZXJzLCBSb3dFeHBhbmRpbmcsIFJvd1BhZ2luYXRpb24sIFJvd1Bpbm5pbmcsIFJvd1NlbGVjdGlvbiwgUm93U29ydGluZywgX2dldFZpc2libGVMZWFmQ29sdW1ucywgYWdncmVnYXRpb25GbnMsIGJ1aWxkSGVhZGVyR3JvdXBzLCBjcmVhdGVDZWxsLCBjcmVhdGVDb2x1bW4sIGNyZWF0ZUNvbHVtbkhlbHBlciwgY3JlYXRlUm93LCBjcmVhdGVUYWJsZSwgZGVmYXVsdENvbHVtblNpemluZywgZXhwYW5kUm93cywgZmlsdGVyRm5zLCBmbGF0dGVuQnksIGZ1bmN0aW9uYWxVcGRhdGUsIGdldENvcmVSb3dNb2RlbCwgZ2V0RXhwYW5kZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZE1pbk1heFZhbHVlcywgZ2V0RmFjZXRlZFJvd01vZGVsLCBnZXRGYWNldGVkVW5pcXVlVmFsdWVzLCBnZXRGaWx0ZXJlZFJvd01vZGVsLCBnZXRHcm91cGVkUm93TW9kZWwsIGdldE1lbW9PcHRpb25zLCBnZXRQYWdpbmF0aW9uUm93TW9kZWwsIGdldFNvcnRlZFJvd01vZGVsLCBpc0Z1bmN0aW9uLCBpc051bWJlckFycmF5LCBpc1Jvd1NlbGVjdGVkLCBpc1N1YlJvd1NlbGVjdGVkLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vLCBub29wLCBvcmRlckNvbHVtbnMsIHBhc3NpdmVFdmVudFN1cHBvcnRlZCwgcmVTcGxpdEFscGhhTnVtZXJpYywgc2VsZWN0Um93c0ZuLCBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyLCBzb3J0aW5nRm5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29sdW1uSGVscGVyIiwiYWNjZXNzb3IiLCJjb2x1bW4iLCJhY2Nlc3NvckZuIiwiYWNjZXNzb3JLZXkiLCJkaXNwbGF5IiwiZ3JvdXAiLCJmdW5jdGlvbmFsVXBkYXRlIiwidXBkYXRlciIsImlucHV0Iiwibm9vcCIsIm1ha2VTdGF0ZVVwZGF0ZXIiLCJrZXkiLCJpbnN0YW5jZSIsInNldFN0YXRlIiwib2xkIiwiaXNGdW5jdGlvbiIsImQiLCJGdW5jdGlvbiIsImlzTnVtYmVyQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsInZhbCIsImZsYXR0ZW5CeSIsImFyciIsImdldENoaWxkcmVuIiwiZmxhdCIsInJlY3Vyc2UiLCJzdWJBcnIiLCJmb3JFYWNoIiwiaXRlbSIsInB1c2giLCJjaGlsZHJlbiIsImxlbmd0aCIsIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiZGVwcyIsInJlc3VsdCIsImRlcEFyZ3MiLCJkZXBUaW1lIiwiZGVidWciLCJEYXRlIiwibm93IiwibmV3RGVwcyIsImRlcHNDaGFuZ2VkIiwic29tZSIsImRlcCIsImluZGV4IiwicmVzdWx0VGltZSIsIm9uQ2hhbmdlIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJnZXRNZW1vT3B0aW9ucyIsInRhYmxlT3B0aW9ucyIsImRlYnVnTGV2ZWwiLCJfdGFibGVPcHRpb25zJGRlYnVnQWwiLCJkZWJ1Z0FsbCIsInByb2Nlc3MiLCJjcmVhdGVDZWxsIiwidGFibGUiLCJyb3ciLCJjb2x1bW5JZCIsImdldFJlbmRlclZhbHVlIiwiX2NlbGwkZ2V0VmFsdWUiLCJjZWxsIiwiZ2V0VmFsdWUiLCJvcHRpb25zIiwicmVuZGVyRmFsbGJhY2tWYWx1ZSIsImlkIiwicmVuZGVyVmFsdWUiLCJnZXRDb250ZXh0IiwiX2ZlYXR1cmVzIiwiZmVhdHVyZSIsImNyZWF0ZUNvbHVtbiIsImNvbHVtbkRlZiIsImRlcHRoIiwicGFyZW50IiwiX3JlZiIsIl9yZXNvbHZlZENvbHVtbkRlZiRpZCIsImRlZmF1bHRDb2x1bW4iLCJfZ2V0RGVmYXVsdENvbHVtbkRlZiIsInJlc29sdmVkQ29sdW1uRGVmIiwicmVwbGFjZSIsInVuZGVmaW5lZCIsImhlYWRlciIsImluY2x1ZGVzIiwib3JpZ2luYWxSb3ciLCJzcGxpdCIsIl9yZXN1bHQiLCJ3YXJuIiwiRXJyb3IiLCJjb2x1bW5zIiwiZ2V0RmxhdENvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMiLCJmbGF0TWFwIiwiZ2V0TGVhZkNvbHVtbnMiLCJfZ2V0T3JkZXJDb2x1bW5zRm4iLCJvcmRlckNvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMyIiwibGVhZkNvbHVtbnMiLCJjcmVhdGVIZWFkZXIiLCJfb3B0aW9ucyRpZCIsImlzUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlcklkIiwic3ViSGVhZGVycyIsImNvbFNwYW4iLCJyb3dTcGFuIiwiaGVhZGVyR3JvdXAiLCJnZXRMZWFmSGVhZGVycyIsImxlYWZIZWFkZXJzIiwicmVjdXJzZUhlYWRlciIsImgiLCJtYXAiLCJIZWFkZXJzIiwiY3JlYXRlVGFibGUiLCJnZXRIZWFkZXJHcm91cHMiLCJnZXRBbGxDb2x1bW5zIiwiZ2V0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0U3RhdGUiLCJjb2x1bW5QaW5uaW5nIiwibGVmdCIsInJpZ2h0IiwiYWxsQ29sdW1ucyIsIl9sZWZ0JG1hcCRmaWx0ZXIiLCJfcmlnaHQkbWFwJGZpbHRlciIsImxlZnRDb2x1bW5zIiwiZmluZCIsImZpbHRlciIsIkJvb2xlYW4iLCJyaWdodENvbHVtbnMiLCJjZW50ZXJDb2x1bW5zIiwiaGVhZGVyR3JvdXBzIiwiYnVpbGRIZWFkZXJHcm91cHMiLCJnZXRDZW50ZXJIZWFkZXJHcm91cHMiLCJnZXRMZWZ0SGVhZGVyR3JvdXBzIiwiX2xlZnQkbWFwJGZpbHRlcjIiLCJvcmRlcmVkTGVhZkNvbHVtbnMiLCJnZXRSaWdodEhlYWRlckdyb3VwcyIsIl9yaWdodCRtYXAkZmlsdGVyMiIsImdldEZvb3Rlckdyb3VwcyIsInJldmVyc2UiLCJnZXRMZWZ0Rm9vdGVyR3JvdXBzIiwiZ2V0Q2VudGVyRm9vdGVyR3JvdXBzIiwiZ2V0UmlnaHRGb290ZXJHcm91cHMiLCJnZXRGbGF0SGVhZGVycyIsImhlYWRlcnMiLCJnZXRMZWZ0RmxhdEhlYWRlcnMiLCJnZXRDZW50ZXJGbGF0SGVhZGVycyIsImdldFJpZ2h0RmxhdEhlYWRlcnMiLCJnZXRDZW50ZXJMZWFmSGVhZGVycyIsImZsYXRIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzIiwiZ2V0TGVmdExlYWZIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzMiIsImdldFJpZ2h0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMzIiwiY2VudGVyIiwiX2xlZnQkMCRoZWFkZXJzIiwiX2xlZnQkIiwiX2NlbnRlciQwJGhlYWRlcnMiLCJfY2VudGVyJCIsIl9yaWdodCQwJGhlYWRlcnMiLCJfcmlnaHQkIiwiY29sdW1uc1RvR3JvdXAiLCJoZWFkZXJGYW1pbHkiLCJfaGVhZGVyR3JvdXBzJDAkaGVhZGUiLCJfaGVhZGVyR3JvdXBzJCIsIm1heERlcHRoIiwiZmluZE1heERlcHRoIiwiZ2V0SXNWaXNpYmxlIiwiY3JlYXRlSGVhZGVyR3JvdXAiLCJoZWFkZXJzVG9Hcm91cCIsImpvaW4iLCJwZW5kaW5nUGFyZW50SGVhZGVycyIsImhlYWRlclRvR3JvdXAiLCJsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyIiwiaXNMZWFmSGVhZGVyIiwiYm90dG9tSGVhZGVycyIsInJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMiLCJmaWx0ZXJlZEhlYWRlcnMiLCJjaGlsZFJvd1NwYW5zIiwiY2hpbGRDb2xTcGFuIiwiY2hpbGRSb3dTcGFuIiwibWluQ2hpbGRSb3dTcGFuIiwiY3JlYXRlUm93Iiwib3JpZ2luYWwiLCJyb3dJbmRleCIsInN1YlJvd3MiLCJwYXJlbnRJZCIsIl92YWx1ZXNDYWNoZSIsIl91bmlxdWVWYWx1ZXNDYWNoZSIsImhhc093blByb3BlcnR5IiwiZ2V0Q29sdW1uIiwiZ2V0VW5pcXVlVmFsdWVzIiwiX3JvdyRnZXRWYWx1ZSIsImdldExlYWZSb3dzIiwiZ2V0UGFyZW50Um93IiwiZ2V0Um93IiwiZ2V0UGFyZW50Um93cyIsInBhcmVudFJvd3MiLCJjdXJyZW50Um93IiwicGFyZW50Um93IiwiZ2V0QWxsQ2VsbHMiLCJnZXRBbGxMZWFmQ29sdW1ucyIsIl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQiLCJhbGxDZWxscyIsInJlZHVjZSIsImFjYyIsImkiLCJDb2x1bW5GYWNldGluZyIsIl9nZXRGYWNldGVkUm93TW9kZWwiLCJnZXRGYWNldGVkUm93TW9kZWwiLCJnZXRQcmVGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRGYWNldGVkVW5pcXVlVmFsdWVzIiwiTWFwIiwiX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRGYWNldGVkTWluTWF4VmFsdWVzIiwiaW5jbHVkZXNTdHJpbmciLCJmaWx0ZXJWYWx1ZSIsInNlYXJjaCIsInRvTG93ZXJDYXNlIiwidG9TdHJpbmciLCJhdXRvUmVtb3ZlIiwidGVzdEZhbHNleSIsImluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlIiwiX3JvdyRnZXRWYWx1ZTIiLCJlcXVhbHNTdHJpbmciLCJfcm93JGdldFZhbHVlMyIsImFyckluY2x1ZGVzIiwiX3JvdyRnZXRWYWx1ZTQiLCJhcnJJbmNsdWRlc0FsbCIsIl9yb3ckZ2V0VmFsdWU1IiwiYXJySW5jbHVkZXNTb21lIiwiX3JvdyRnZXRWYWx1ZTYiLCJlcXVhbHMiLCJ3ZWFrRXF1YWxzIiwiaW5OdW1iZXJSYW5nZSIsInJvd1ZhbHVlIiwicmVzb2x2ZUZpbHRlclZhbHVlIiwidW5zYWZlTWluIiwidW5zYWZlTWF4IiwicGFyc2VkTWluIiwicGFyc2VGbG9hdCIsInBhcnNlZE1heCIsIk51bWJlciIsImlzTmFOIiwiSW5maW5pdHkiLCJ0ZW1wIiwiZmlsdGVyRm5zIiwiQ29sdW1uRmlsdGVyaW5nIiwiZ2V0RGVmYXVsdENvbHVtbkRlZiIsImZpbHRlckZuIiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RhdGUiLCJjb2x1bW5GaWx0ZXJzIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJvbkNvbHVtbkZpbHRlcnNDaGFuZ2UiLCJmaWx0ZXJGcm9tTGVhZlJvd3MiLCJtYXhMZWFmUm93RmlsdGVyRGVwdGgiLCJnZXRBdXRvRmlsdGVyRm4iLCJmaXJzdFJvdyIsImdldENvcmVSb3dNb2RlbCIsImZsYXRSb3dzIiwidmFsdWUiLCJnZXRGaWx0ZXJGbiIsIl90YWJsZSRvcHRpb25zJGZpbHRlciIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjIiLCJnZXRDYW5GaWx0ZXIiLCJfY29sdW1uJGNvbHVtbkRlZiRlbmEiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUyIiwiZW5hYmxlQ29sdW1uRmlsdGVyIiwiZW5hYmxlQ29sdW1uRmlsdGVycyIsImVuYWJsZUZpbHRlcnMiLCJnZXRJc0ZpbHRlcmVkIiwiZ2V0RmlsdGVySW5kZXgiLCJnZXRGaWx0ZXJWYWx1ZSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTIiLCJfdGFibGUkZ2V0U3RhdGUkY29sdW0zIiwiZmluZEluZGV4Iiwic2V0RmlsdGVyVmFsdWUiLCJzZXRDb2x1bW5GaWx0ZXJzIiwicHJldmlvdXNGaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzaG91bGRBdXRvUmVtb3ZlRmlsdGVyIiwiX29sZCRmaWx0ZXIiLCJuZXdGaWx0ZXJPYmoiLCJfb2xkJG1hcCIsIl90YWJsZSIsImNvbHVtbkZpbHRlcnNNZXRhIiwidXBkYXRlRm4iLCJfZnVuY3Rpb25hbFVwZGF0ZSIsInJlc2V0Q29sdW1uRmlsdGVycyIsImRlZmF1bHRTdGF0ZSIsIl90YWJsZSRpbml0aWFsU3RhdGUkYyIsIl90YWJsZSRpbml0aWFsU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJnZXRGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZpbHRlcmVkUm93TW9kZWwiLCJtYW51YWxGaWx0ZXJpbmciLCJzdW0iLCJfbGVhZlJvd3MiLCJjaGlsZFJvd3MiLCJuZXh0IiwibmV4dFZhbHVlIiwiZXh0ZW50IiwibWVhbiIsImxlYWZSb3dzIiwiY291bnQiLCJtZWRpYW4iLCJ2YWx1ZXMiLCJtaWQiLCJmbG9vciIsIm51bXMiLCJzb3J0IiwiYSIsImIiLCJ1bmlxdWUiLCJmcm9tIiwiU2V0IiwidW5pcXVlQ291bnQiLCJzaXplIiwiX2NvbHVtbklkIiwiYWdncmVnYXRpb25GbnMiLCJDb2x1bW5Hcm91cGluZyIsImFnZ3JlZ2F0ZWRDZWxsIiwicHJvcHMiLCJfdG9TdHJpbmciLCJfcHJvcHMkZ2V0VmFsdWUiLCJhZ2dyZWdhdGlvbkZuIiwiZ3JvdXBpbmciLCJvbkdyb3VwaW5nQ2hhbmdlIiwiZ3JvdXBlZENvbHVtbk1vZGUiLCJ0b2dnbGVHcm91cGluZyIsInNldEdyb3VwaW5nIiwiZ2V0Q2FuR3JvdXAiLCJfcmVmMiIsIl9yZWYzIiwiZW5hYmxlR3JvdXBpbmciLCJnZXRJc0dyb3VwZWQiLCJfdGFibGUkZ2V0U3RhdGUkZ3JvdXAiLCJnZXRHcm91cGVkSW5kZXgiLCJfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyIiwiaW5kZXhPZiIsImdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciIsImNhbkdyb3VwIiwiZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJjYWxsIiwiZ2V0QWdncmVnYXRpb25GbiIsIl90YWJsZSRvcHRpb25zJGFnZ3JlZyIsIl90YWJsZSRvcHRpb25zJGFnZ3JlZzIiLCJyZXNldEdyb3VwaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRnIiwiZ2V0UHJlR3JvdXBlZFJvd01vZGVsIiwiZ2V0R3JvdXBlZFJvd01vZGVsIiwiX2dldEdyb3VwZWRSb3dNb2RlbCIsIm1hbnVhbEdyb3VwaW5nIiwiZ3JvdXBpbmdDb2x1bW5JZCIsImdldEdyb3VwaW5nVmFsdWUiLCJfZ3JvdXBpbmdWYWx1ZXNDYWNoZSIsImdldElzUGxhY2Vob2xkZXIiLCJnZXRJc0FnZ3JlZ2F0ZWQiLCJfcm93JHN1YlJvd3MiLCJub25Hcm91cGluZ0NvbHVtbnMiLCJjb2wiLCJncm91cGluZ0NvbHVtbnMiLCJnIiwiQ29sdW1uT3JkZXJpbmciLCJjb2x1bW5PcmRlciIsIm9uQ29sdW1uT3JkZXJDaGFuZ2UiLCJnZXRJbmRleCIsInBvc2l0aW9uIiwiX2dldFZpc2libGVMZWFmQ29sdW1ucyIsImdldElzRmlyc3RDb2x1bW4iLCJfY29sdW1ucyQiLCJnZXRJc0xhc3RDb2x1bW4iLCJfY29sdW1ucyIsInNldENvbHVtbk9yZGVyIiwicmVzZXRDb2x1bW5PcmRlciIsIm9yZGVyZWRDb2x1bW5zIiwiY29sdW1uT3JkZXJDb3B5IiwiY29sdW1uc0NvcHkiLCJ0YXJnZXRDb2x1bW5JZCIsInNoaWZ0IiwiZm91bmRJbmRleCIsInNwbGljZSIsImdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUiLCJDb2x1bW5QaW5uaW5nIiwib25Db2x1bW5QaW5uaW5nQ2hhbmdlIiwicGluIiwiY29sdW1uSWRzIiwic2V0Q29sdW1uUGlubmluZyIsIl9vbGQkbGVmdDMiLCJfb2xkJHJpZ2h0MyIsIl9vbGQkbGVmdCIsIl9vbGQkcmlnaHQiLCJfb2xkJGxlZnQyIiwiX29sZCRyaWdodDIiLCJnZXRDYW5QaW4iLCJfZCRjb2x1bW5EZWYkZW5hYmxlUGkiLCJlbmFibGVQaW5uaW5nIiwiZW5hYmxlQ29sdW1uUGlubmluZyIsImdldElzUGlubmVkIiwibGVhZkNvbHVtbklkcyIsImlzTGVmdCIsImlzUmlnaHQiLCJnZXRQaW5uZWRJbmRleCIsImdldENlbnRlclZpc2libGVDZWxscyIsIl9nZXRBbGxWaXNpYmxlQ2VsbHMiLCJsZWZ0QW5kUmlnaHQiLCJnZXRMZWZ0VmlzaWJsZUNlbGxzIiwiY2VsbHMiLCJnZXRSaWdodFZpc2libGVDZWxscyIsInJlc2V0Q29sdW1uUGlubmluZyIsImdldElzU29tZUNvbHVtbnNQaW5uZWQiLCJfcGlubmluZ1N0YXRlJHBvc2l0aW8iLCJwaW5uaW5nU3RhdGUiLCJfcGlubmluZ1N0YXRlJGxlZnQiLCJfcGlubmluZ1N0YXRlJHJpZ2h0IiwiZ2V0TGVmdExlYWZDb2x1bW5zIiwiZ2V0UmlnaHRMZWFmQ29sdW1ucyIsImdldENlbnRlckxlYWZDb2x1bW5zIiwiZGVmYXVsdENvbHVtblNpemluZyIsIm1pblNpemUiLCJtYXhTaXplIiwiTUFYX1NBRkVfSU5URUdFUiIsImdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUiLCJzdGFydE9mZnNldCIsInN0YXJ0U2l6ZSIsImRlbHRhT2Zmc2V0IiwiZGVsdGFQZXJjZW50YWdlIiwiaXNSZXNpemluZ0NvbHVtbiIsImNvbHVtblNpemluZ1N0YXJ0IiwiQ29sdW1uU2l6aW5nIiwiY29sdW1uU2l6aW5nIiwiY29sdW1uU2l6aW5nSW5mbyIsImNvbHVtblJlc2l6ZU1vZGUiLCJjb2x1bW5SZXNpemVEaXJlY3Rpb24iLCJvbkNvbHVtblNpemluZ0NoYW5nZSIsIm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSIsImdldFNpemUiLCJfY29sdW1uJGNvbHVtbkRlZiRtaW4iLCJfY29sdW1uJGNvbHVtbkRlZiRtYXgiLCJjb2x1bW5TaXplIiwiZ2V0U3RhcnQiLCJzbGljZSIsImdldEFmdGVyIiwicmVzZXRTaXplIiwic2V0Q29sdW1uU2l6aW5nIiwiXyIsInJlc3QiLCJnZXRDYW5SZXNpemUiLCJlbmFibGVSZXNpemluZyIsImVuYWJsZUNvbHVtblJlc2l6aW5nIiwiZ2V0SXNSZXNpemluZyIsIl9oZWFkZXIkY29sdW1uJGdldFNpeiIsInByZXZTaWJsaW5nSGVhZGVyIiwiZ2V0UmVzaXplSGFuZGxlciIsIl9jb250ZXh0RG9jdW1lbnQiLCJjYW5SZXNpemUiLCJlIiwicGVyc2lzdCIsImlzVG91Y2hTdGFydEV2ZW50IiwidG91Y2hlcyIsImNsaWVudFgiLCJuZXdDb2x1bW5TaXppbmciLCJ1cGRhdGVPZmZzZXQiLCJldmVudFR5cGUiLCJjbGllbnRYUG9zIiwic2V0Q29sdW1uU2l6aW5nSW5mbyIsIl9vbGQkc3RhcnRPZmZzZXQiLCJfb2xkJHN0YXJ0U2l6ZSIsImRlbHRhRGlyZWN0aW9uIiwiaGVhZGVyU2l6ZSIsIm9uTW92ZSIsIm9uRW5kIiwiY29udGV4dERvY3VtZW50IiwiZG9jdW1lbnQiLCJtb3VzZUV2ZW50cyIsIm1vdmVIYW5kbGVyIiwidXBIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvdWNoRXZlbnRzIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiX2UkdG91Y2hlcyQiLCJwYXNzaXZlSWZTdXBwb3J0ZWQiLCJwYXNzaXZlRXZlbnRTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc2V0Q29sdW1uU2l6aW5nIiwicmVzZXRIZWFkZXJTaXplSW5mbyIsIl90YWJsZSRpbml0aWFsU3RhdGUkYzIiLCJnZXRUb3RhbFNpemUiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAyIiwiZ2V0TGVmdFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRyIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRzIiLCJnZXRDZW50ZXJUb3RhbFNpemUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUyIiwiZ2V0UmlnaHRUb3RhbFNpemUiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIyIiwicGFzc2l2ZVN1cHBvcnRlZCIsInN1cHBvcnRlZCIsIndpbmRvdyIsImVyciIsInR5cGUiLCJDb2x1bW5WaXNpYmlsaXR5IiwiY29sdW1uVmlzaWJpbGl0eSIsIm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSIsInRvZ2dsZVZpc2liaWxpdHkiLCJnZXRDYW5IaWRlIiwic2V0Q29sdW1uVmlzaWJpbGl0eSIsImNoaWxkQ29sdW1ucyIsImMiLCJlbmFibGVIaWRpbmciLCJnZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciIsInRhcmdldCIsImNoZWNrZWQiLCJnZXRWaXNpYmxlQ2VsbHMiLCJtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QiLCJnZXRDb2x1bW5zIiwiZ2V0VmlzaWJsZUZsYXRDb2x1bW5zIiwiZ2V0QWxsRmxhdENvbHVtbnMiLCJnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMiLCJyZXNldENvbHVtblZpc2liaWxpdHkiLCJ0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSIsIl92YWx1ZSIsImdldElzQWxsQ29sdW1uc1Zpc2libGUiLCJvYmoiLCJnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSIsImdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciIsIl90YXJnZXQiLCJHbG9iYWxGaWx0ZXJpbmciLCJnbG9iYWxGaWx0ZXIiLCJvbkdsb2JhbEZpbHRlckNoYW5nZSIsImdsb2JhbEZpbHRlckZuIiwiZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyIiwiX3RhYmxlJGdldENvcmVSb3dNb2RlIiwiZ2V0Q2FuR2xvYmFsRmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Q29sIiwiZW5hYmxlR2xvYmFsRmlsdGVyIiwiZ2V0R2xvYmFsQXV0b0ZpbHRlckZuIiwiZ2V0R2xvYmFsRmlsdGVyRm4iLCJzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldEdsb2JhbEZpbHRlciIsIl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJnZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJfZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJSb3dFeHBhbmRpbmciLCJleHBhbmRlZCIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJwYWdpbmF0ZUV4cGFuZGVkUm93cyIsInJlZ2lzdGVyZWQiLCJxdWV1ZWQiLCJfYXV0b1Jlc2V0RXhwYW5kZWQiLCJfdGFibGUkb3B0aW9ucyRhdXRvUmUiLCJfcXVldWUiLCJhdXRvUmVzZXRBbGwiLCJhdXRvUmVzZXRFeHBhbmRlZCIsIm1hbnVhbEV4cGFuZGluZyIsInJlc2V0RXhwYW5kZWQiLCJzZXRFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsImdldElzQWxsUm93c0V4cGFuZGVkIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRlIiwiZ2V0Q2FuU29tZVJvd3NFeHBhbmQiLCJnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwiLCJnZXRDYW5FeHBhbmQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyIiwiZ2V0SXNTb21lUm93c0V4cGFuZGVkIiwia2V5cyIsImdldFJvd01vZGVsIiwiZ2V0SXNFeHBhbmRlZCIsImdldEV4cGFuZGVkRGVwdGgiLCJyb3dJZHMiLCJyb3dzQnlJZCIsInNwbGl0SWQiLCJnZXRQcmVFeHBhbmRlZFJvd01vZGVsIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJnZXRFeHBhbmRlZFJvd01vZGVsIiwiX2dldEV4cGFuZGVkUm93TW9kZWwiLCJ0b2dnbGVFeHBhbmRlZCIsIl9leHBhbmRlZCIsImV4aXN0cyIsIm9sZEV4cGFuZGVkIiwicm93SWQiLCJfdGFibGUkb3B0aW9ucyRnZXRJc1IiLCJnZXRJc1Jvd0V4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Um93IiwiZ2V0Um93Q2FuRXhwYW5kIiwiZW5hYmxlRXhwYW5kaW5nIiwiZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQiLCJpc0Z1bGx5RXhwYW5kZWQiLCJnZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIiLCJjYW5FeHBhbmQiLCJkZWZhdWx0UGFnZUluZGV4IiwiZGVmYXVsdFBhZ2VTaXplIiwiZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSIsInBhZ2VJbmRleCIsInBhZ2VTaXplIiwiUm93UGFnaW5hdGlvbiIsInBhZ2luYXRpb24iLCJvblBhZ2luYXRpb25DaGFuZ2UiLCJfYXV0b1Jlc2V0UGFnZUluZGV4IiwiYXV0b1Jlc2V0UGFnZUluZGV4IiwibWFudWFsUGFnaW5hdGlvbiIsInJlc2V0UGFnZUluZGV4Iiwic2V0UGFnaW5hdGlvbiIsInNhZmVVcGRhdGVyIiwibmV3U3RhdGUiLCJyZXNldFBhZ2luYXRpb24iLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAiLCJzZXRQYWdlSW5kZXgiLCJtYXhQYWdlSW5kZXgiLCJwYWdlQ291bnQiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAyIiwicmVzZXRQYWdlU2l6ZSIsIl90YWJsZSRpbml0aWFsU3RhdGUkcDMiLCJfdGFibGUkaW5pdGlhbFN0YXRlMiIsInNldFBhZ2VTaXplIiwidG9wUm93SW5kZXgiLCJzZXRQYWdlQ291bnQiLCJfdGFibGUkb3B0aW9ucyRwYWdlQ28iLCJuZXdQYWdlQ291bnQiLCJnZXRQYWdlT3B0aW9ucyIsImdldFBhZ2VDb3VudCIsInBhZ2VPcHRpb25zIiwiZmlsbCIsImdldENhblByZXZpb3VzUGFnZSIsImdldENhbk5leHRQYWdlIiwicHJldmlvdXNQYWdlIiwibmV4dFBhZ2UiLCJmaXJzdFBhZ2UiLCJsYXN0UGFnZSIsImdldFBhZ2luYXRpb25Sb3dNb2RlbCIsIl9nZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfdGFibGUkb3B0aW9ucyRwYWdlQ28yIiwiY2VpbCIsImdldFJvd0NvdW50IiwiX3RhYmxlJG9wdGlvbnMkcm93Q291Iiwicm93Q291bnQiLCJyb3dzIiwiZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSIsInRvcCIsImJvdHRvbSIsIlJvd1Bpbm5pbmciLCJyb3dQaW5uaW5nIiwib25Sb3dQaW5uaW5nQ2hhbmdlIiwiaW5jbHVkZUxlYWZSb3dzIiwiaW5jbHVkZVBhcmVudFJvd3MiLCJsZWFmUm93SWRzIiwicGFyZW50Um93SWRzIiwic2V0Um93UGlubmluZyIsIl9vbGQkdG9wMyIsIl9vbGQkYm90dG9tMyIsIl9vbGQkdG9wIiwiX29sZCRib3R0b20iLCJoYXMiLCJfb2xkJHRvcDIiLCJfb2xkJGJvdHRvbTIiLCJlbmFibGVSb3dQaW5uaW5nIiwiaXNUb3AiLCJpc0JvdHRvbSIsIl90YWJsZSRfZ2V0UGlubmVkUm93cyIsIl92aXNpYmxlUGlubmVkUm93SWRzJCIsInZpc2libGVQaW5uZWRSb3dJZHMiLCJfZ2V0UGlubmVkUm93cyIsIl9yZWY0IiwicmVzZXRSb3dQaW5uaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRyIiwiZ2V0SXNTb21lUm93c1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkdG9wIiwiX3Bpbm5pbmdTdGF0ZSRib3R0b20iLCJ2aXNpYmxlUm93cyIsInBpbm5lZFJvd0lkcyIsIl90YWJsZSRvcHRpb25zJGtlZXBQaSIsImtlZXBQaW5uZWRSb3dzIiwiZ2V0VG9wUm93cyIsImdldEJvdHRvbVJvd3MiLCJnZXRDZW50ZXJSb3dzIiwiYWxsUm93cyIsInRvcEFuZEJvdHRvbSIsIlJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbiIsIm9uUm93U2VsZWN0aW9uQ2hhbmdlIiwiZW5hYmxlUm93U2VsZWN0aW9uIiwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24iLCJlbmFibGVTdWJSb3dTZWxlY3Rpb24iLCJzZXRSb3dTZWxlY3Rpb24iLCJyZXNldFJvd1NlbGVjdGlvbiIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsImdldElzQWxsUm93c1NlbGVjdGVkIiwicHJlR3JvdXBlZEZsYXRSb3dzIiwiZ2V0Q2FuU2VsZWN0IiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInJlc29sdmVkVmFsdWUiLCJnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJtdXRhdGVSb3dJc1NlbGVjdGVkIiwiZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCIsImdldFNlbGVjdGVkUm93TW9kZWwiLCJyb3dNb2RlbCIsInNlbGVjdFJvd3NGbiIsImdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCIsImdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJwYWdpbmF0aW9uRmxhdFJvd3MiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NvbWVSb3dzU2VsZWN0ZWQiLCJfdGFibGUkZ2V0U3RhdGUkcm93U2UiLCJ0b3RhbFNlbGVjdGVkIiwiZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU2VsZWN0ZWQiLCJnZXRJc1NvbWVTZWxlY3RlZCIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIiLCJnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciIsInRvZ2dsZVNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsIl9vcHRzJHNlbGVjdENoaWxkcmVuIiwic2VsZWN0ZWRSb3dJZHMiLCJzZWxlY3RDaGlsZHJlbiIsImlzUm93U2VsZWN0ZWQiLCJpc1N1YlJvd1NlbGVjdGVkIiwiZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQiLCJnZXRDYW5TZWxlY3RTdWJSb3dzIiwiZ2V0Q2FuTXVsdGlTZWxlY3QiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyIiwiY2FuU2VsZWN0IiwiaW5jbHVkZUNoaWxkcmVuIiwibmV3U2VsZWN0ZWRGbGF0Um93cyIsIm5ld1NlbGVjdGVkUm93c0J5SWQiLCJyZWN1cnNlUm93cyIsIl9yb3ckc3ViUm93czIiLCJzZWxlY3Rpb24iLCJfc2VsZWN0aW9uJHJvdyRpZCIsIl9yb3ckc3ViUm93czMiLCJhbGxDaGlsZHJlblNlbGVjdGVkIiwic29tZVNlbGVjdGVkIiwic3ViUm93Iiwic3ViUm93Q2hpbGRyZW5TZWxlY3RlZCIsInJlU3BsaXRBbHBoYU51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJyb3dBIiwicm93QiIsImNvbXBhcmVBbHBoYW51bWVyaWMiLCJhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlIiwidGV4dCIsImNvbXBhcmVCYXNpYyIsInRleHRDYXNlU2Vuc2l0aXZlIiwiZGF0ZXRpbWUiLCJiYXNpYyIsImFTdHIiLCJiU3RyIiwiYWEiLCJiYiIsImFuIiwicGFyc2VJbnQiLCJibiIsImNvbWJvIiwic29ydGluZ0ZucyIsIlJvd1NvcnRpbmciLCJzb3J0aW5nIiwic29ydGluZ0ZuIiwic29ydFVuZGVmaW5lZCIsIm9uU29ydGluZ0NoYW5nZSIsImlzTXVsdGlTb3J0RXZlbnQiLCJzaGlmdEtleSIsImdldEF1dG9Tb3J0aW5nRm4iLCJmaXJzdFJvd3MiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJlbmFibGVNdWx0aVNvcnQiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkiLCJjb2x1bW5Tb3J0IiwiZ2V0U29ydEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMiIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aTMiLCJjbGVhclNvcnRpbmciLCJnZXRUb2dnbGVTb3J0aW5nSGFuZGxlciIsImNhblNvcnQiLCJyZXNldFNvcnRpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHMiLCJnZXRQcmVTb3J0ZWRSb3dNb2RlbCIsIl9nZXRTb3J0ZWRSb3dNb2RlbCIsIm1hbnVhbFNvcnRpbmciLCJidWlsdEluRmVhdHVyZXMiLCJfb3B0aW9ucyRfZmVhdHVyZXMiLCJfb3B0aW9ucyRpbml0aWFsU3RhdGUiLCJkZWJ1Z1RhYmxlIiwiZGVmYXVsdE9wdGlvbnMiLCJhc3NpZ24iLCJtZXJnZU9wdGlvbnMiLCJjb3JlSW5pdGlhbFN0YXRlIiwiX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IiwicXVldWVkVGltZW91dCIsImNvcmVJbnN0YW5jZSIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZXNldCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9nZXRSb3dJZCIsImdldFJvd0lkIiwiX2dldENvcmVSb3dNb2RlbCIsInNlYXJjaEFsbCIsIl9kZWZhdWx0Q29sdW1uIiwiX3Byb3BzJHJlbmRlclZhbHVlJHRvIiwiX3Byb3BzJHJlbmRlclZhbHVlIiwiX2dldENvbHVtbkRlZnMiLCJjb2x1bW5EZWZzIiwicmVjdXJzZUNvbHVtbnMiLCJncm91cGluZ0NvbHVtbkRlZiIsIl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQiLCJmbGF0Q29sdW1ucyIsImRhdGEiLCJhY2Nlc3NSb3dzIiwib3JpZ2luYWxSb3dzIiwiZ2V0U3ViUm93cyIsIl9yb3ckb3JpZ2luYWxTdWJSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwiZXhwYW5kUm93cyIsImV4cGFuZGVkUm93cyIsImhhbmRsZVJvdyIsIl90YWJsZSRnZXRDb2x1bW4iLCJmYWNldGVkUm93TW9kZWwiLCJfZmFjZXRlZFJvd01vZGVsJGZsYXQiLCJmaXJzdFZhbHVlIiwiZmFjZXRlZE1pbk1heFZhbHVlcyIsImoiLCJmaWx0ZXJSb3dzIiwiZmlsdGVyUm93SW1wbCIsImZpbHRlclJvd01vZGVsRnJvbUxlYWZzIiwiZmlsdGVyUm93TW9kZWxGcm9tUm9vdCIsInJvd3NUb0ZpbHRlciIsImZpbHRlclJvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYSIsIm5ld0ZpbHRlcmVkRmxhdFJvd3MiLCJuZXdGaWx0ZXJlZFJvd3NCeUlkIiwicmVjdXJzZUZpbHRlclJvd3MiLCJuZXdSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEyIiwicGFzcyIsInByZVJvd01vZGVsIiwiZmlsdGVyYWJsZUlkcyIsImZpbHRlclJvd3NJbXBsIiwiZmFjZXRlZFVuaXF1ZVZhbHVlcyIsIl9mYWNldGVkVW5pcXVlVmFsdWVzJCIsInNldCIsImdldCIsInJlc29sdmVkQ29sdW1uRmlsdGVycyIsInJlc29sdmVkR2xvYmFsRmlsdGVycyIsIl9maWx0ZXJGbiRyZXNvbHZlRmlsdCIsImdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMiLCJfZ2xvYmFsRmlsdGVyRm4kcmVzb2wiLCJjdXJyZW50Q29sdW1uRmlsdGVyIiwiY3VycmVudEdsb2JhbEZpbHRlciIsImZpbHRlck1ldGEiLCJfX2dsb2JhbF9fIiwiZXhpc3RpbmdHcm91cGluZyIsImdyb3VwZWRGbGF0Um93cyIsImdyb3VwZWRSb3dzQnlJZCIsImdyb3VwVXBSZWN1cnNpdmVseSIsInJvd0dyb3Vwc01hcCIsImdyb3VwQnkiLCJhZ2dyZWdhdGVkR3JvdXBlZFJvd3MiLCJlbnRyaWVzIiwiZ3JvdXBpbmdWYWx1ZSIsImdyb3VwZWRSb3dzIiwiX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIiwiYWdncmVnYXRlRm4iLCJncm91cE1hcCIsInJlc0tleSIsInByZXZpb3VzIiwicGFnZVN0YXJ0IiwicGFnZUVuZCIsInBhZ2luYXRlZFJvd01vZGVsIiwic29ydGluZ1N0YXRlIiwic29ydGVkRmxhdFJvd3MiLCJhdmFpbGFibGVTb3J0aW5nIiwiY29sdW1uSW5mb0J5SWQiLCJzb3J0RW50cnkiLCJpbnZlcnRTb3J0aW5nIiwic29ydERhdGEiLCJzb3J0ZWREYXRhIiwiX3NvcnRFbnRyeSRkZXNjIiwiY29sdW1uSW5mbyIsImlzRGVzYyIsInNvcnRJbnQiLCJhVmFsdWUiLCJiVmFsdWUiLCJhVW5kZWZpbmVkIiwiYlVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;